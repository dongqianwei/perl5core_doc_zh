=head1 名称

perlguts - Perl API介绍

=head1 描述

本文档试图描述如何使用Perl API，同时提供一些Perl核心基本功能的信息。
本文档仍未完成且可能包含很多错误。如有问题或注释请向下面列出的作者提出。

=head1 变量

=head2 数据类型

Perl有三种typedef定义，用于处理Perl的三种主要数据类型。

    SV Scalar Value
    AV Array Value
    HV Hash Value

每种typedef都有相应的数据管理例程。

=head2 什么是"IV"?

Perl使用typedef:'IV'(一个有符号整型，空间足以保存一个指针)。另外还有typedef:'UV'(一个无符号的'IV')。

Perl同样适用I32和I16两个特殊的typedef，通常至少有32位或16位长(同样也有U32和U64)。但是在Crays上，它们都是64位。

=head2 使用SV

一个SV可以用一条指令创建并加载。有五种类型的值可以被加载：整型值(IV)，无符号整型值(UV)，双精度浮点型(NV)，
字符串(PV)以及另一个scalar(SV)。("PV"代表"指针值",你也许认为这里用错了名字，因为它被描述为一个指向字符串的指针。
然而它实际上可以指向其它类型的数据。例如，被用于正则表达式的数据结构中的反向列表就是一堆scalar，每一个都包含一个通过PV访问的UV数组。
但是将PV用于字符串之外的地方需要特别小心，因为很多内部的封装都假设PV是用于字符串的。非字符串的应用文档中只在此处提及。)

这七个例程如下：

    SV*  newSViv(IV);
    SV*  newSVuv(UV);
    SV*  newSVnv(double);
    SV*  newSVpv(const char*, STRLEN);
    SV*  newSVpvn(const char*, STRLEN);
    SV*  newSVpvf(const char*, ...);
    SV*  newSVsv(SV*);

C<STRLEN>是整型(Size_t, 通常在config.h文件中被定义为size_t)，保证足够大以容纳任何perl可以处理的字符串的长度。

在一些不太可能发生的场景中SV需要更加复杂的初始化方式，你可以用newSV(len)创建一个空的SV。
如果len为0，一个类型为NULL的空SV将会返回，否则一个PV类型的的内存分配大小为len+1字节且内容都为NULL的SV将会返回，
可以通过SvPVX访问。在以上两种场景中SV的值都是undef。

    SV *sv = newSV(0);   /* 不分配内存  */
    SV *sv = newSV(10);  /* 10 (+1) 字节未初始化的内存将本分配 */

有八种操作用于改变（已存在的）SV的值。

    void  sv_setiv(SV*, IV);
    void  sv_setuv(SV*, UV);
    void  sv_setnv(SV*, double);
    void  sv_setpv(SV*, const char*);
    void  sv_setpvn(SV*, const char*, STRLEN)
    void  sv_setpvf(SV*, const char*, ...);
    void  sv_vsetpvfn(SV*, const char*, STRLEN, va_list *, SV **, I32, bool *);
    void  sv_setsv(SV*, SV*);

注意：你可以使用C<sv_setpvn>，C<newSVpvn>或C<newSVpv>设置传入字符串的长度，
也可以用C<sv_setpv>或C<newSVpv>（第二个参数传0）让Perl自己计算字符串的长度，
Perl会使用C<strlen>来获取字符串的长度，因此你传入的字符串必须以NUL结尾，且中间不能包含NUL。

C<sv_setpvf>参数的处理类似于C<sprintf>，格式化后的输出将被赋予SV*。

C<sv_vsetpvfn>与C<vsprintf>类似，但是它允许你指定一个指向参数列表的指针或者一个SV数组的地址和它的长度。
最后一个参数指向一个boolean值；返回后，如果boolean为true，则地区设定识别码将被用于格式化字符串。
因此该字符串的内容是不可信的（请参见L<perlsec>）。如果该信息不重要的话这个指针的值可以为NUL。注意该函数要求你提供格式的长度。

C<sv_set*()>系列函数在操作“有魔力的”值的时候并不通用。参见本文中L<魔法虚表> 一节。

所有包含字符串的SV都应当以NUL结尾。如果不这样的话将会有将非NUL结尾字符串传入需要通过NUL判断字符串结束的C函数或系统调用从而导致进程崩溃风险。因此Perl自己的函数一般都会在尾部添加NUL。当你将一个存在SV中的字符串传入C函数或系统调用的时候一定要万分小心。

为得到SV指向的真实值，你可以用以下宏：

    SvIV(SV*)
    SvUV(SV*)
    SvNV(SV*)
    SvPV(SV*, STRLEN len)
    SvPV_nolen(SV*)

它们将把scalar类型自动转为IV，UV，double或字符串。

对于C<SvPV>这个宏，返回字符串的长度将被存放于变量C<len>中（这是一个宏，应此你不需要使用len的地址）。
如果你不介意数据的长度，使用宏C<SvPV_nolen>，历史上，C<SvPV>宏结合C<PL_na>全局变量被使用在该场景下。
但是这样非常低效，因为C<PL_na>的位置位于支持多线程的Perl中的线程专属内存中。
请记住，在任何场景下Perl之支持包含NUL或不以NUL结尾的字符串。

Also remember that C doesn't allow you to safely say C<foo(SvPV(s, len),
len);>. It might work with your compiler, but it won't work for everyone.
Break this sort of statement up into separate assignments:

同时请记住C语言不允许你安全得使用C<foo(SvPV(s, len)。这样的用法可能在你的编译器上可以正常编译，但不保证对所有人都适用。
请将这种类型的语句拆分成多条赋值语句：

    SV *s;
    STRLEN len;
    char *ptr;
    ptr = SvPV(s, len);
    foo(ptr, len);

如果你想知道某个scalar值是否为TRUE，你可以使用：

    SvTRUE(SV*)

尽管Perl将会自动为你的字符串分配内存，但是如果你需要强制为SV分配更多的内存的话，使用宏：

    SvGROW(SV*, STRLEN newlen)

这将会检测是否需要分配更多的内存，如果是，它将会调用函数C<sv_grow>。
请注意C<SvGROW>只会增加内存，且分配的内存不会自动在末尾添加NUL字节所占用的空间（perl内部一般都使用C<SvGROW(sv, len + 1)>）。

如果你想知道Perl认为一个SV中存储数据的的类型，可以使用如下的宏进行检查：

    SvIOK(SV*)
    SvNOK(SV*)
    SvPOK(SV*)

你可以使用以下宏获取当前存储在SV中的字符串的长度：

    SvCUR(SV*)
    SvCUR_set(SV*, I32 val)

你同样可以使用以下宏获取指向SV中字符串末尾的指针：

    SvEND(SV*)

但是请注意最后三个宏只有在C<SvPOK()>返回真的时候才能合法使用。

如果你希望在C<SV*>中储存的字符串后面添加数据，可以使用如下函数：

    void  sv_catpv(SV*, const char*);
    void  sv_catpvn(SV*, const char*, STRLEN);
    void  sv_catpvf(SV*, const char*, ...);
    void  sv_vcatpvfn(SV*, const char*, STRLEN, va_list *, SV **, I32, bool);
    void  sv_catsv(SV*, SV*);

The first function calculates the length of the string to be appended by
using C<strlen>.  In the second, you specify the length of the string
yourself.  The third function processes its arguments like C<sprintf> and
appends the formatted output.  The fourth function works like C<vsprintf>.
You can specify the address and length of an array of SVs instead of the
va_list argument. The fifth function extends the string stored in the first
SV with the string stored in the second SV.  It also forces the second SV
to be interpreted as a string.

第一个函数使用C<strlen>计算需要添加的字符串长度。
第二个函数需要你自己指定字符串长度。
第三个函数以类似于C<sprintf>的方式格式化字符串并将结果添加到末尾。
第四个函数类似于C<vsprintf>，你可以指定一个SV数组的地址和长度以取代va_list参数。
第五个函数用第二个SV*中的字符串拓展第一个参数。当然它会将第二个参数解析为字符串类型。

The C<sv_cat*()> functions are not generic enough to operate on values that
have "magic".  See L<Magic Virtual Tables> later in this document.

C<sv_cat*()>系列的函数对于有"魔法的"值来说并不通用。请看下面的L<Magic Virtual Tables>章节。

If you know the name of a scalar variable, you can get a pointer to its SV
by using the following:

如果你知道scalar变量的名字，你可以用以下这种方式获取到一个指向SV的指针。

    SV*  get_sv("package::varname", 0);

This returns NULL if the variable does not exist.

如果变量不存在的话将会返回NULL。

If you want to know if this variable (or any other SV) is actually C<defined>,
you can call:

如果你想知道某个变量是否被定义，你可以调用：

    SvOK(SV*)

The scalar C<undef> value is stored in an SV instance called C<PL_sv_undef>.

scalar值undef存在一个名字叫PL_sv_undef的SV实例中。

Its address can be used whenever an C<SV*> is needed. Make sure that
you don't try to compare a random sv with C<&PL_sv_undef>. For example
when interfacing Perl code, it'll work correctly for:

它的地址可以被用于任何一个以 C<SV*> 为参数的地方。确保你不会用一个SV与C<&PL_sv_undef>进行比较。例如当与Perl代码交互的时候，如下方可以正常工作：

  foo(undef);

But won't work when called as:

但是这样调用就无法工作了：

  $x = undef;
  foo($x);

So to repeat always use SvOK() to check whether an sv is defined.

所以请用SvOK()来检查sv是否被定义。

Also you have to be careful when using C<&PL_sv_undef> as a value in
AVs or HVs (see L<AVs, HVs and undefined values>).

同样当时使用 C<&PL_sv_undef> 作为AVs或HVs的值的时候千万要小心（参见L<AVs，HVs和undefined值>章节）。

There are also the two values C<PL_sv_yes> and C<PL_sv_no>, which contain
boolean TRUE and FALSE values, respectively.  Like C<PL_sv_undef>, their
addresses can be used whenever an C<SV*> is needed.

同样C<PL_sv_yes>和C<PL_sv_no>是两个包含了布尔值TRUE和FALSE的值。
和C<PL_sv_undef>一样，它们的地址同样可以被用于任何期望C<SV*>的地方。

Do not be fooled into thinking that C<(SV *) 0> is the same as C<&PL_sv_undef>.
Take this code:

不要认为C<(SV *) 0>和C<&PL_sv_undef>是一样的，请看以下代码：

    SV* sv = (SV*) 0;
    if (I-am-to-return-a-real-value) {
            sv = sv_2mortal(newSViv(42));
    }
    sv_setsv(ST(0), sv);

This code tries to return a new SV (which contains the value 42) if it should
return a real value, or undef otherwise.  Instead it has returned a NULL
pointer which, somewhere down the line, will cause a segmentation violation,
bus error, or just weird results.  Change the zero to C<&PL_sv_undef> in the
first line and all will be well.

这段代码在应当返回实数的时候返回42，否则返回undef。但是它实际上返回的是一个NULL指针，
将会导致内存段冲突或错误或一些奇怪的情况。将第一行中的0修改为C<&PL_sv_undef>会解决这个问题。

To free an SV that you've created, call C<SvREFCNT_dec(SV*)>.  Normally this
call is not necessary (see L<Reference Counts and Mortality>).

为了释放一个你创建的SV，调用C<SvREFCNT_dec(SV*)>。通常你不需要调用这个方法（请看L<引用计数与销毁>）。

=head2 偏移

=head2 Offsets

Perl provides the function C<sv_chop> to efficiently remove characters
from the beginning of a string; you give it an SV and a pointer to
somewhere inside the PV, and it discards everything before the
pointer. The efficiency comes by means of a little hack: instead of
actually removing the characters, C<sv_chop> sets the flag C<OOK>
(offset OK) to signal to other functions that the offset hack is in
effect, and it puts the number of bytes chopped off into the IV field
of the SV. It then moves the PV pointer (called C<SvPVX>) forward that
many bytes, and adjusts C<SvCUR> and C<SvLEN>.

Perl提供了函数 C<sv_chop> 用于高效地移除字符串开头的字符；你传入一个SV和一个指向PV某处地址的指针，它将会移除指针前的全部字符。
它的效率源于一点hack技巧：它实际上并没有真正移除掉这些字符，<sv_chop>设置了C<OOK>(offset OK)字段用于向其他函数表明使用了这种偏移的hack技巧，
同时它将被移除的字符的个数存入到SV中的IV字段。然后它将PV指针（称作C<SvPVX>）向前移动那么多字节，并适配 C<SvCUR> 和 C<SvLEN>。

Hence, at this point, the start of the buffer that we allocated lives
at C<SvPVX(sv) - SvIV(sv)> in memory and the PV pointer is pointing
into the middle of this allocated storage.

因此在这一点上，我们分配的缓冲区的起始点位于内存中的 C<SvPVX(sv) - SvIV(sv)> ，而PV指针指向分配的内存中间的区域。

This is best demonstrated by example:

用下面这个例子可以很好地说明：

  % ./perl -Ilib -MDevel::Peek -le '$a="12345"; $a=~s/.//; Dump($a)'
  SV = PVIV(0x8128450) at 0x81340f0
    REFCNT = 1
    FLAGS = (POK,OOK,pPOK)
    IV = 1  (OFFSET)
    PV = 0x8135781 ( "1" . ) "2345"\0
    CUR = 4
    LEN = 5

Here the number of bytes chopped off (1) is put into IV, and
C<Devel::Peek::Dump> helpfully reminds us that this is an offset. The
portion of the string between the "real" and the "fake" beginnings is
shown in parentheses, and the values of C<SvCUR> and C<SvLEN> reflect
the fake beginning, not the real one.

这里被切除的字符序列长度1被存如IV中，而且C<Devel::Peek::Dump>包提示我们这是一个偏移量。
在实际和伪起始位置之间的字符串显示在括号中，C<SvCUR>和C<SvLEN>表示的是伪起始位置，不是实际的值。

Something similar to the offset hack is performed on AVs to enable
efficient shifting and splicing off the beginning of the array; while
C<AvARRAY> points to the first element in the array that is visible from
Perl, C<AvALLOC> points to the real start of the C array. These are
usually the same, but a C<shift> operation can be carried out by
increasing C<AvARRAY> by one and decreasing C<AvFILL> and C<AvMAX>.
Again, the location of the real start of the C array only comes into
play when freeing the array. See C<av_shift> in F<av.c>.

与这种偏移的hack技巧类似的方法被应用于高效地移除或切除数组的开头元素；尽管C<AvARRAY>指向的是Perl看来array的起始位置，
C<AvALLOC> 指向的才是数组的实际起始位置。
它们通常都是一样的，但是 C<shift> 操作是通过 C<AvARRAY> 加1并且减少 C<AvFILL> 和 C<AvMAX>的方式实现的。
数组实际的位置只有在需要释放内存的时候才会被用到。参见F<av.c>文件中的C<av_shift>。

=head2 SV的结构

=head2 What's Really Stored in an SV?

Recall that the usual method of determining the type of scalar you have is
to use C<Sv*OK> macros.  Because a scalar can be both a number and a string,
usually these macros will always return TRUE and calling the C<Sv*V>
macros will do the appropriate conversion of string to integer/double or
integer/double to string.

请回忆，为了判断SV的实际类型我们通常会使用C<Sv*OK>系列的宏。由于scalar可以同时是一个数字和字符串，
通常这些宏都会返回TRUE，并且调用调用C<Sv*V>系列的宏会自动对SV作出合适的转换。

If you I<really> need to know if you have an integer, double, or string
pointer in an SV, you can use the following three macros instead:

如果你真的需要知道SV中指向的究竟是一个整型，浮点型还是字符串，你可以使用下面三个宏代替：

    SvIOKp(SV*)
    SvNOKp(SV*)
    SvPOKp(SV*)

These will tell you if you truly have an integer, double, or string pointer
stored in your SV.  The "p" stands for private. 

这些方法可以检测SV中存储的究竟是整型，浮点型或者字符串指针。"p"代表private。

There are various ways in which the private and public flags may differ.
For example, a tied SV may have a valid underlying value in the IV slot
(so SvIOKp is true), but the data should be accessed via the FETCH
routine rather than directly, so SvIOK is false. Another is when
numeric conversion has occurred and precision has been lost: only the
private flag is set on 'lossy' values. So when an NV is converted to an
IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.

在很多情况下public和private标记是不同的。例如，一个tied的SV在IV槽中有一个合法的值（也就是说SvIOKp为true），
但是它的数据要通过FETCH方法简介获取，因此SvIOK为false。另一种情况是当发生了数字强转且丢失精度的时候：
只有private标记被设置为'lossy'。所以当NV被转为IV且丢失精度的时候，SvIOKp，SvNOKp和SvNOK都会被设置，而SvIOK不会。

In general, though, it's best to use the C<Sv*V> macros.

总而言之，最好使用C<Sv*V>系列的宏。

=head2 使用AVs

=head2 Working with AVs

There are two ways to create and load an AV.  The first method creates an
empty AV:

有两种方式可以创建并加载一个AV。第一种方法创建一个新的AV：

    AV*  newAV();

The second method both creates the AV and initially populates it with SVs:

第二种方法同时创建并用SVs初始化。

    AV*  av_make(I32 num, SV **ptr);

The second argument points to an array containing C<num> C<SV*>'s.  Once the
AV has been created, the SVs can be destroyed, if so desired.

第二个参数指向一个包含了num个SV*的指针。一旦AV被创建，Svs就可以被销毁，如果你希望这样的话。

Once the AV has been created, the following operations are possible on it:

一旦AV被创建，可以对其进行如下操作：

    void  av_push(AV*, SV*);
    SV*   av_pop(AV*);
    SV*   av_shift(AV*);
    void  av_unshift(AV*, I32 num);

These should be familiar operations, with the exception of C<av_unshift>.
This routine adds C<num> elements at the front of the array with the C<undef>
value.  You must then use C<av_store> (described below) to assign values
to these new elements.

这些都是你所熟悉的操作，除了av_unshift会在数组的前端添加num个值为undef的元素。你必须使用av_store为这些新元素赋值。

Here are some other functions:

这里还有其他一些函数：

    I32   av_top_index(AV*);
    SV**  av_fetch(AV*, I32 key, I32 lval);
    SV**  av_store(AV*, I32 key, SV* val);

The C<av_top_index> function returns the highest index value in an array (just
like $#array in Perl).  If the array is empty, -1 is returned.  The
C<av_fetch> function returns the value at index C<key>, but if C<lval>
is non-zero, then C<av_fetch> will store an undef value at that index.
The C<av_store> function stores the value C<val> at index C<key>, and does
not increment the reference count of C<val>.  Thus the caller is responsible
for taking care of that, and if C<av_store> returns NULL, the caller will
have to decrement the reference count to avoid a memory leak.  Note that
C<av_fetch> and C<av_store> both return C<SV**>'s, not C<SV*>'s as their
return value.

av_top_index返回数组的最大索引值（类似于Perl中的$#array）。如果数组为空则返回-1。av_fetch返回数组中索引为key的值，
但是如果lval非0，则av_fetch将会在那个索引处存入undef。av_store将在索引key处存入val，
并且不会增加val的引用计数。因此调用者需要处理它的索引计数，如果av_store返回NULL的话，调用者需要减少引用计数以防止内存泄漏。
注意，av_fetch和av_store都会返回SV**，而不是SV*作为它们的返回值。

A few more:

更多函数：

    void  av_clear(AV*);
    void  av_undef(AV*);
    void  av_extend(AV*, I32 key);

The C<av_clear> function deletes all the elements in the AV* array, but
does not actually delete the array itself.  The C<av_undef> function will
delete all the elements in the array plus the array itself.  The
C<av_extend> function extends the array so that it contains at least C<key+1>
elements.  If C<key+1> is less than the currently allocated length of the array,
then nothing is done.

av_clear将会删除AV*数组中所有的元素，但是并不会删除数组自身。av_undef将会删除数组的全部元素以及它自己。
av_extend函数将会拓展数组，因此它至少包含key+1个元素。如果key+1小于当前分配的数组长度，那么什么操作都不会进行。

If you know the name of an array variable, you can get a pointer to its AV
by using the following:

如果你知道数组的名字，你也可以这样获取一个指向这个AV的指针：

    AV*  get_av("package::varname", 0);

This returns NULL if the variable does not exist.

如果变量不存在的话将会返回NULL。

See L<Understanding the Magic of Tied Hashes and Arrays> for more
information on how to use the array access functions on tied arrays.

请看 '理解tied的hashes和arrays的魔法' 以获得更多或如何对tied array使用数组访问函数的信息。

=head2 使用HV

=head2 Working with HVs

To create an HV, you use the following routine:

你可以使用如下方法创建HV：

    HV*  newHV();

Once the HV has been created, the following operations are possible on it:

当HV被创建后，以下可以对其进行一下操作：

    SV**  hv_store(HV*, const char* key, U32 klen, SV* val, U32 hash);
    SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval);

The C<klen> parameter is the length of the key being passed in (Note that
you cannot pass 0 in as a value of C<klen> to tell Perl to measure the
length of the key).  The C<val> argument contains the SV pointer to the
scalar being stored, and C<hash> is the precomputed hash value (zero if
you want C<hv_store> to calculate it for you).  The C<lval> parameter
indicates whether this fetch is actually a part of a store operation, in
which case a new undefined value will be added to the HV with the supplied
key and C<hv_fetch> will return as if the value had already existed.

klen参数是你传入的key的长度（注意你不能传入0值，让Perl自己判断key的长度）。val参数存有一个指向需要存入的scalar的SV指针，
hash参数是预计算的hash值（如果你希望Perl为你算的话传入0）。lval参数决定了fetch操作是不是store操作的一部分，
在这种情况下一个新的undefined值会被加入到HV中指定key值的地方并且hv_fetch将会返回就好像这个值已经存在了一样。

Remember that C<hv_store> and C<hv_fetch> return C<SV**>'s and not just
C<SV*>.  To access the scalar value, you must first dereference the return
value.  However, you should check to make sure that the return value is
not NULL before dereferencing it.

记住 C<hv_store> 和 C<hv_fetch> 返回 C<SV**> 类型的值而不是C<SV*>，
为了获取scalar值，你必须先对返回值解引用。
然而，你应该先检查返回值非NULL再解引用。

The first of these two functions checks if a hash table entry exists, and the 
second deletes it.

下面这两个函数，第一个检查一个哈希表中是否存在某个键值，第二个删除它。

    bool  hv_exists(HV*, const char* key, U32 klen);
    SV*   hv_delete(HV*, const char* key, U32 klen, I32 flags);

If C<flags> does not include the C<G_DISCARD> flag then C<hv_delete> will
create and return a mortal copy of the deleted value.

如果 C<G_DISCARD> 标记不存在则 C<hv_delete> 将会创建并返回一个被删除值的拷贝。

And more miscellaneous functions:

更多函数：

    void   hv_clear(HV*);
    void   hv_undef(HV*);

Like their AV counterparts, C<hv_clear> deletes all the entries in the hash
table but does not actually delete the hash table.  The C<hv_undef> deletes
both the entries and the hash table itself.

和针对AV操作的其他对应函数一样，C<hv_clear> 删除哈希表中所有的键值，但不会删除哈希表。C<hv_undef>同时删除键值和表。

Perl keeps the actual data in a linked list of structures with a typedef of HE.
These contain the actual key and value pointers (plus extra administrative
overhead).  The key is a string pointer; the value is an C<SV*>.  However,
once you have an C<HE*>, to get the actual key and value, use the routines
specified below.

Perl将实际的值保存在使用HE typedef的结构体链表中。它们包含了实际的键和指向值的指针（以及其他用于管理的头部）。
键是一个字符串指针；值是一个C<SV*>。然而，当你拥有一个C<HE*>时，使用如下函数获取实际的键值：

    I32    hv_iterinit(HV*);
            /* Prepares starting point to traverse hash table */
    HE*    hv_iternext(HV*);
            /* Get the next entry, and return a pointer to a
               structure that has both the key and value */
    char*  hv_iterkey(HE* entry, I32* retlen);
            /* Get the key from an HE structure and also return
               the length of the key string */
    SV*    hv_iterval(HV*, HE* entry);
            /* Return an SV pointer to the value of the HE
               structure */
    SV*    hv_iternextsv(HV*, char** key, I32* retlen);
            /* This convenience routine combines hv_iternext,
	       hv_iterkey, and hv_iterval.  The key and retlen
	       arguments are return values for the key and its
	       length.  The value is returned in the SV* argument */

If you know the name of a hash variable, you can get a pointer to its HV
by using the following:

如果你知道哈希变量的名字，你可以用如下方法获取指向这个HV的指针：

    HV*  get_hv("package::varname", 0);

This returns NULL if the variable does not exist.

如果这个变量不存则会返回NULL。

The hash algorithm is defined in the C<PERL_HASH> macro:

哈希算法是通过C<PERL_HASH>宏定义的：

    PERL_HASH(hash, key, klen)

The exact implementation of this macro varies by architecture and version
of perl, and the return value may change per invocation, so the value
is only valid for the duration of a single perl process.

这个宏的实现与架构和perl的版本有关，它的返回值每次调用都可能不一样，所以它的值只有在某一个perl进程内有效。

See L<Understanding the Magic of Tied Hashes and Arrays> for more
information on how to use the hash access functions on tied hashes.

请看 L<理解tied的哈希表和数组的魔法> 一节以获取更多关于如何使用哈希表访问函数访问tied哈希表的信息。

=head2 哈希拓展API

=head2 Hash API Extensions

Beginning with version 5.004, the following functions are also supported:

自从5.004版本开始支持以下函数：

    HE*     hv_fetch_ent  (HV* tb, SV* key, I32 lval, U32 hash);
    HE*     hv_store_ent  (HV* tb, SV* key, SV* val, U32 hash);

    bool    hv_exists_ent (HV* tb, SV* key, U32 hash);
    SV*     hv_delete_ent (HV* tb, SV* key, I32 flags, U32 hash);

    SV*     hv_iterkeysv  (HE* entry);

Note that these functions take C<SV*> keys, which simplifies writing
of extension code that deals with hash structures.  These functions
also allow passing of C<SV*> keys to C<tie> functions without forcing
you to stringify the keys (unlike the previous set of functions).

注意，这些函数使用 C<SV*> 类型的键，这样简化了需要处理哈希结构的代码。
这些函数同样允许传递C<SV*>类型的键给C<tie>函数而不需要你将键强转为字符串（和之前的那些函数不同）。

They also return and accept whole hash entries (C<HE*>), making their
use more efficient (since the hash number for a particular string
doesn't have to be recomputed every time).  See L<perlapi> for detailed
descriptions.

它们同样返回并接受完整的哈希键值结构（C<HE*>），使得它们更加高效（因为特定字符串的哈希值不用每次都重复计算）。
请看L<perlapi>以了解更多细节。

The following macros must always be used to access the contents of hash
entries.  Note that the arguments to these macros must be simple
variables, since they may get evaluated more than once.  See
L<perlapi> for detailed descriptions of these macros.

以下宏只能用于获取哈希键值结构的内容。注意这些宏的参数只能是简单的变量，因为它们可能会被计算多次。请看perlapi以了解更多细节。

    HePV(HE* he, STRLEN len)
    HeVAL(HE* he)
    HeHASH(HE* he)
    HeSVKEY(HE* he)
    HeSVKEY_force(HE* he)
    HeSVKEY_set(HE* he, SV* sv)

These two lower level macros are defined, but must only be used when
dealing with keys that are not C<SV*>s:

这两个底层的宏只能被用于键不是C<SV*>的情况。

    HeKEY(HE* he)
    HeKLEN(HE* he)

Note that both C<hv_store> and C<hv_store_ent> do not increment the
reference count of the stored C<val>, which is the caller's responsibility.
If these functions return a NULL value, the caller will usually have to
decrement the reference count of C<val> to avoid a memory leak.

请注意C<hv_store>和C<hv_store_ent>都不会增加C<val>的引用计数，这都是调用者需要做的。
如果这些函数返回NULL值，调用者必须要减少C<val>的引用计数的值以避免内存泄漏。

=head2 AVs，HVs和undefined值

=head2 AVs, HVs and undefined values

Sometimes you have to store undefined values in AVs or HVs. Although
this may be a rare case, it can be tricky. That's because you're
used to using C<&PL_sv_undef> if you need an undefined SV.

有时你需要在AVs和HVs中存储undefined值。尽管这样的情形很少，但是却会很诡异。因为如果你需要一个未定义SV的时候会习惯于使用C<&PL_sv_undef>。

For example, intuition tells you that this XS code:

例如，直觉会告诉你以下XS代码：

    AV *av = newAV();
    av_store( av, 0, &PL_sv_undef );

is equivalent to this Perl code:

与以下代码等价：

    my @av;
    $av[0] = undef;

Unfortunately, this isn't true. AVs use C<&PL_sv_undef> as a marker
for indicating that an array element has not yet been initialized.
Thus, C<exists $av[0]> would be true for the above Perl code, but
false for the array generated by the XS code.

不幸的是这不是真的。AV使用&PL_sv_undef作为元素没有被初始化的标识。应此C<exists $av[0]>对于Perl代码来说为真，但是对于XS代码来说却为假。

Other problems can occur when storing C<&PL_sv_undef> in HVs:

当在HV中存储C<&PL_sv_undef>的时候也会出问题：

    hv_store( hv, "key", 3, &PL_sv_undef, 0 );

This will indeed make the value C<undef>, but if you try to modify
the value of C<key>, you'll get the following error:

这样的确会使值为undef，但是当你试图改变key对应的值的时候将会得到以下错误：

    Modification of non-creatable hash value attempted

    试图改变没有被创建的哈希值

In perl 5.8.0, C<&PL_sv_undef> was also used to mark placeholders
in restricted hashes. This caused such hash entries not to appear
when iterating over the hash or when checking for the keys
with the C<hv_exists> function.

在Perl5.8.0中，C<&PL_sv_undef>也被用于在'受限'哈希表中标记占位符。
这样会导致哈希键值在遍历哈希表或使用C<hv_exists>的时候不会出现。

You can run into similar problems when you store C<&PL_sv_yes> or
C<&PL_sv_no> into AVs or HVs. Trying to modify such elements
will give you the following error:

当你将C<&PL_sv_yes>或C<&PL_sv_no>存入AV或HV的时候会遇到类似的问题。试图去改变这些元素的时候会产生如下错误：

    Modification of a read-only value attempted

    试图改变只读类型的值

To make a long story short, you can use the special variables
C<&PL_sv_undef>, C<&PL_sv_yes> and C<&PL_sv_no> with AVs and
HVs, but you have to make sure you know what you're doing.

长话短说，你可以将C<&PL_sv_undef>，C<&PL_sv_yes>或C<&PL_sv_no>这些特殊变量用于AVs和HVs，
但是请确保你清楚自己在做什么。

Generally, if you want to store an undefined value in an AV
or HV, you should not use C<&PL_sv_undef>, but rather create a
new undefined value using the C<newSV> function, for example:

如果你想在AV或HV中存储一个undefined值的时候，不应该使用C<&PL_sv_undef>，
而是用newSV创建一个新的未定义值，例如：

    av_store( av, 42, newSV(0) );
    hv_store( hv, "foo", 3, newSV(0), 0 );

=head2 引用

=head2 References

References are a special type of scalar that point to other data types
(including other references).

引用是一种特殊的scalar类型，用于指向其他的数据类型（包括引用类型）。

To create a reference, use either of the following functions:

请使用下列函数创建一个引用：

    SV* newRV_inc((SV*) thing);
    SV* newRV_noinc((SV*) thing);

The C<thing> argument can be any of an C<SV*>, C<AV*>, or C<HV*>.  The
functions are identical except that C<newRV_inc> increments the reference
count of the C<thing>, while C<newRV_noinc> does not.  For historical
reasons, C<newRV> is a synonym for C<newRV_inc>.

参数C<thing>可以是C<SV*>，C<AV*>或C<HV*>中的任意一种。
这两个函数除了C<newRV_inc>会增加C<thing>的引用计数外，其他方面都是完全一样。
C<newRV>就是C<newRV_inc>的匿名方法（某些历史原因导致的）。

Once you have a reference, you can use the following macro to dereference
the reference:

当你有一个引用的时候，你可以使用下列宏来对其解引用：

    SvRV(SV*)

then call the appropriate routines, casting the returned C<SV*> to either an
C<AV*> or C<HV*>, if required.

然后调用合适的方法，如果需要的话，将返回的C<SV*>强转为C<AV*>C<HV*>。

To determine if an SV is a reference, you can use the following macro:

可以用下面的宏判断一个SV是否为一个引用。

    SvROK(SV*)

To discover what type of value the reference refers to, use the following
macro and then check the return value.

为了发现引用指向的类型，使用下列宏然后检查返回值。

    SvTYPE(SvRV(SV*))

The most useful types that will be returned are:

最有用的返回类型有如下几种：

    SVt_PVAV    Scalar
    SVt_PVAV    Array
    SVt_PVHV    Hash
    SVt_PVCV    Code
    SVt_PVGV    Glob (possibly a file handle)

See L<perlapi/svtype> for more details.

请参考 L<perlapi/svtype> 以获得更多细节。

=head2 被blessed的引用和类对象

=head2 Blessed References and Class Objects

References are also used to support object-oriented programming.  In perl's
OO lexicon, an object is simply a reference that has been blessed into a
package (or class).  Once blessed, the programmer may now use the reference
to access the various methods in the class.

引用同样可以被用于支持面向对象编程。在Perl的OO语法中，一个对象就是一个被blessed到包（或类）之中的引用。
一旦被blessed，程序员就可以使用这个引用访问类的各种方法。

A reference can be blessed into a package with the following function:

一个引用可以通过使用如下方法被blessed到包中：

    SV* sv_bless(SV* sv, HV* stash);

The C<sv> argument must be a reference value.  The C<stash> argument
specifies which class the reference will belong to.  See
L<Stashes and Globs> for information on converting class names into stashes.

参数sv必须为引用类型。参数stash指定了引用所属的类。查看 'Stashes 和 Globs'章节 以获的更多关于将类名转为stash的信息。

/* Still under construction */

/* 仍在建设中 */

The following function upgrades rv to reference if not already one.
Creates a new SV for rv to point to.  If C<classname> is non-null, the SV
is blessed into the specified class.  SV is returned.

下列函数将参数rv升级为引用。使得rv指向一个新创建的SV。如果classname不是NULL的话，SV将会被blessed成制定的类。将返回这个SV。

	SV* newSVrv(SV* rv, const char* classname);

The following three functions copy integer, unsigned integer or double
into an SV whose reference is C<rv>.  SV is blessed if C<classname> is
non-null.

下面三个函数拷贝整型，无符号整型或浮点型到一个引用为rv的SV中。如果classname非空的话SV将被blessed。

	SV* sv_setref_iv(SV* rv, const char* classname, IV iv);
	SV* sv_setref_uv(SV* rv, const char* classname, UV uv);
	SV* sv_setref_nv(SV* rv, const char* classname, NV iv);

The following function copies the pointer value (I<the address, not the
string!>) into an SV whose reference is rv.  SV is blessed if C<classname>
is non-null.

下面的函数拷贝指针的值到rv引用指向的SV里。如果C<classname>非空的话SV将被blessed。

	SV* sv_setref_pv(SV* rv, const char* classname, void* pv);

The following function copies a string into an SV whose reference is C<rv>.
Set length to 0 to let Perl calculate the string length.  SV is blessed if
C<classname> is non-null.

下面的函数将字符串拷贝到C<rv>指向的SV里，当length为0的时候Perl会自动计算字符串的长度。如果C<classname>非空的话SV将被blessed。

    SV* sv_setref_pvn(SV* rv, const char* classname, char* pv,
                                                         STRLEN length);

The following function tests whether the SV is blessed into the specified
class.  It does not check inheritance relationships.

下面的函数测试SV是否被blessed成某种特定的类。它不会检查继承关系。

	int  sv_isa(SV* sv, const char* name);

The following function tests whether the SV is a reference to a blessed object.

下面的函数测试SV是否为一个被blessed过的引用。

	int  sv_isobject(SV* sv);

The following function tests whether the SV is derived from the specified
class. SV can be either a reference to a blessed object or a string
containing a class name. This is the function implementing the
C<UNIVERSAL::isa> functionality.

下面的函数测试SV是否继承自某个特定的类。SV既可以是一个被blessed过的引用也可以是包含类名的字符串。
就是这个函数实现了C<UNIVERSAL::isa>的功能。

	bool sv_derived_from(SV* sv, const char* name);

To check if you've got an object derived from a specific class you have
to write:

为了检查你是否得到了一个继承自特定类的对象，请使用：

	if (sv_isobject(sv) && sv_derived_from(sv, class)) { ... }

=head2 创建新变量

=head2 Creating New Variables

To create a new Perl variable with an undef value which can be accessed from
your Perl script, use the following routines, depending on the variable type.

为了创建一个你可以用脚本访问到的值为undef的新的Perl变量，根据变量的类型使用以下函数：

    SV*  get_sv("package::varname", GV_ADD);
    AV*  get_av("package::varname", GV_ADD);
    HV*  get_hv("package::varname", GV_ADD);

Notice the use of GV_ADD as the second parameter.  The new variable can now
be set, using the routines appropriate to the data type.

请注意第二个参数GC_ADD。用合适的方法就可以设置合适类型的变量。

There are additional macros whose values may be bitwise OR'ed with the
C<GV_ADD> argument to enable certain extra features.  Those bits are:

也有额外的宏，其值会被用于和GV_ADD相或以开启新的特性。这些宏如下：

=over

=item GV_ADDMULTI

Marks the variable as multiply defined, thus preventing the:

标记这个变量是多重定义的，应此避免了：

    Name <varname> used only once: possible typo

warning.

    名称为 'varname' 的变量只适用了一次：可能为打字错误

的警告。

=item GV_ADDWARN

Issues the warning:

表明了如下警告：

    Had to create <varname> unexpectedly

    if the variable did not exist before the function was called.

-

    如果变量名为varname的变量在函数调用时不存在的时候必须要创建它。

=back

If you do not specify a package name, the variable is created in the current
package.

如果你没有指定包名，变量将会创建在在当前包中。

=head2 引用计数和销毁

=head2 Reference Counts and Mortality

Perl uses a reference count-driven garbage collection mechanism. SVs,
AVs, or HVs (xV for short in the following) start their life with a
reference count of 1.  If the reference count of an xV ever drops to 0,
then it will be destroyed and its memory made available for reuse.

Perl使用引用计数的垃圾收集机制。在SV，AV或HV（以下用xV代替）生命周期的开始它们的引用计数被初始化为1。
如果xV的引用计数降低到0，它将会被销毁以释放内存。

This normally doesn't happen at the Perl level unless a variable is
undef'ed or the last variable holding a reference to it is changed or
overwritten.  At the internal level, however, reference counts can be
manipulated with the following macros:

这通常不会发生在Perl语言的层面，除非一个变量被执行undef操作或者最有一个保存引用的变量被修改或覆盖。
在Perl内部实现的层面可以通过以下宏管理引用计数。

    int SvREFCNT(SV* sv);
    SV* SvREFCNT_inc(SV* sv);
    void SvREFCNT_dec(SV* sv);

However, there is one other function which manipulates the reference
count of its argument.  The C<newRV_inc> function, you will recall,
creates a reference to the specified argument.  As a side effect,
it increments the argument's reference count.  If this is not what
you want, use C<newRV_noinc> instead.

还有一个可以管理其参数引用计数的函数。newRV_inc可以创建它参数的一个引用。
它的副作用是增加其参数的引用计数。如果这不是你想要的效果，使用newRV_noinc来代替。

For example, imagine you want to return a reference from an XSUB function.
Inside the XSUB routine, you create an SV which initially has a reference
count of one.  Then you call C<newRV_inc>, passing it the just-created SV.
This returns the reference as a new SV, but the reference count of the
SV you passed to C<newRV_inc> has been incremented to two.  Now you
return the reference from the XSUB routine and frget about the SV.
But Perl hasn't!  Whenever the returned reference is destroyed, the
reference count of the original SV is decreased to one and nothing happens.
The SV will hang around without any way to access it until Perl itself
terminates.  This is a memory leak.

例如，想象一下你想要从XSUB函数返回一个引用。在XSUB函数内，你创建了一个引用计数为1的SV。
然后你调用了newRV_inc，传入刚刚创建的SV，它会将对SV的引用作为一个新的SV返回。
此时你传入的SV的引用计数已经是2了。现在你将这个引用从XSUB函数中返回并且忘掉了传入的那个SV。
但是Perl没有！当返回的引用被销毁有，原先那个SV的引用计数变成1，什么都不会发生。
这个SV将会一直存在直到Perl进程终止。这就是一个内存泄漏。

The correct procedure, then, is to use C<newRV_noinc> instead of
C<newRV_inc>.  Then, if and when the last reference is destroyed,
the reference count of the SV will go to zero and it will be destroyed,
stopping any memory leak.

正确的做法是使用newRV_noinc取代newRV_inc。
然后如果最后一个引用被销毁，SV的引用计数变为0它将会被销毁，避免了内存泄漏。

There are some convenience functions available that can help with the
destruction of xVs.  These functions introduce the concept of "mortality".
An xV that is mortal has had its reference count marked to be decremented,
but not actually decremented, until "a short time later".  Generally the
term "short time later" means a single Perl statement, such as a call to
an XSUB function.  The actual determinant for when mortal xVs have their
reference count decremented depends on two macros, SAVETMPS and FREETMPS.
See L<perlcall> and L<perlxs> for more details on these macros.

还有一些更加方便的函数可以帮助你销毁xV。这些函数引入了"死亡性"这个概念。
一个xV是"将死的"如果它的引用计数被标记为"减少的"，但是并没有实际减少而是"延迟到之后再减少"。
一般来说"延迟之后"意味着一条Perl语句，例如调用一个XSUB函数。
"将死"的xV的引用计数实际减少的时机是由两个宏决定的，SAVETMPS和FREETMPS。
请看perlcall和perlxs以获得更多关于这些宏的细节。

"Mortalization" then is at its simplest a deferred C<SvREFCNT_dec>.
However, if you mortalize a variable twice, the reference count will
later be decremented twice.

"死亡性"可以理解为一个延时的SvREFCNT_dec。如果你'将死'一个变量两次，引用计数将会在之后减少两次。


"Mortal" SVs are mainly used for SVs that are placed on perl's stack.
For example an SV which is created just to pass a number to a called sub
is made mortal to have it cleaned up automatically when it's popped off
the stack. Similarly, results returned by XSUBs (which are pushed on the
stack) are often made mortal.

"将死"的SV通常被用于那些被分配在perl的栈上的SV。
例如一个被创建用于传入一个数字到到函数中的SV，将被设置为'将死的'以使其在被栈弹出时自动释放。
同样的，XSUB返回的结果（被放置到栈上）通常也会被设置为"将死的"。

To create a mortal variable, use the functions:

为了创建一个"将死的"变量，使用如下函数：

    SV*  sv_newmortal()
    SV*  sv_2mortal(SV*)
    SV*  sv_mortalcopy(SV*)

The first call creates a mortal SV (with no value), the second converts an existing
SV to a mortal SV (and thus defers a call to C<SvREFCNT_dec>), and the
third creates a mortal copy of an existing SV.
Because C<sv_newmortal> gives the new SV no value, it must normally be given one
via C<sv_setpv>, C<sv_setiv>, etc. :

第一个调用创建一个没有值的将死SV，第二个函数将一个已经存在的SV转为将死的SV（也就是说延迟了一次SvREFCNT_dec的调用），
第三个函数创建了一个已存在SV的将死SV拷贝。
因为sv_newmortal没有给新建的SV设置任何值，
它通常必须要用sv_setpv或sv_setiv等设置一个值:

    SV *tmp = sv_newmortal();
    sv_setiv(tmp, an_integer);

As that is multiple C statements it is quite common so see this idiom instead:

那是写成多条C语句，通常以下用法也经常可以看到。

    SV *tmp = sv_2mortal(newSViv(an_integer));


You should be careful about creating mortal variables.  Strange things
can happen if you make the same value mortal within multiple contexts,
or if you make a variable mortal multiple times. Thinking of "Mortalization"
as deferred C<SvREFCNT_dec> should help to minimize such problems.
For example if you are passing an SV which you I<know> has a high enough REFCNT
to survive its use on the stack you need not do any mortalization.
If you are not sure then doing an C<SvREFCNT_inc> and C<sv_2mortal>, or
making a C<sv_mortalcopy> is safer.

在创建"将死"变量的时候要非常仔细。如果你在多个场景下将同一个变量设置为'将死'或将一个变量设置多次，
可能会导致奇怪的事情发生。将"将死性"想象成延迟的Sv_REFCNT_dec可以帮之你减少这样的问题。
例如如果你传入一个引用计数足够大（可以在栈上存活）的SV，就不需要设置为'将死'了。如果你不确定那么可以先做一次SvREFCNT_inc操作在调用sv_2mortal，
或者使用sv_mortalcopy将会更加安全。

The mortal routines are not just for SVs; AVs and HVs can be
made mortal by passing their address (type-casted to C<SV*>) to the
C<sv_2mortal> or C<sv_mortalcopy> routines.

'将死化'函数不仅仅可用于SV；AV和HV也可以通过将它们的地址（强转为类型SV*）传入sv_2mortal或sv_mortalcopy方法以设置为'将死的';

=head2 Stashes和Globs

=head2 Stashes and Globs

A B<stash> is a hash that contains all variables that are defined
within a package.  Each key of the stash is a symbol
name (shared by all the different types of objects that have the same
name), and each value in the hash table is a GV (Glob Value).  This GV
in turn contains references to the various objects of that name,
including (but not limited to) the following:

一个stash是一个包括了一个包里面全部变量定义的哈希。stash中的每一个键都是一个符号名（被所有不同类型的同名对象共享），
哈希表中的每一个值都是一个GV（Glob Value）。
这个GV同样包含了各种叫那个名字的对象的引用，包括（但不限于）以下几种：

    Scalar Value
    Array Value
    Hash Value
    I/O Handle
    Format
    Subroutine

There is a single stash called C<PL_defstash> that holds the items that exist
in the C<main> package.  To get at the items in other packages, append the
string "::" to the package name.  The items in the C<Foo> package are in
the stash C<Foo::> in PL_defstash.  The items in the C<Bar::Baz> package are
in the stash C<Baz::> in C<Bar::>'s stash.

有一个称作C<PL_defstash>的stash存储了C<main>包中的全部成员。要得到其他包中的成员，在包名后添加"::"。
C<Foo>包中的成员在PL_defstash中名为C<Foo::>的stash中。C<Bar::Baz>包中的成员在C<Baz::>的stash中的C<Bar::>的stash中。

To get the stash pointer for a particular package, use the function:

为了得到特定包的stash指针，使用下列函数：

    HV*  gv_stashpv(const char* name, I32 flags)
    HV*  gv_stashsv(SV*, I32 flags)

The first function takes a literal string, the second uses the string stored
in the SV.  Remember that a stash is just a hash table, so you get back an
C<HV*>.  The C<flags> flag will create a new package if it is set to GV_ADD.

第一个函数需要传入一个字面字符串，第二个使用SV中储存的字符串。记住stash仅仅是一个哈希表，因此你可以获取一个C<HV*>返回值。
当C<flags>标记被设置为GV_ADD的时候将会创建一个新包。

The name that C<gv_stash*v> wants is the name of the package whose symbol table
you want.  The default package is called C<main>.  If you have multiply nested
packages, pass their names to C<gv_stash*v>, separated by C<::> as in the Perl
language itself.

C<gv_stash*v>系列函数需要的参数name就是你需要的符号表所属的包的名字。默认的包名为C<main>。
如果你有多重嵌套的包，请用C<::>将它们分割传入C<gv_stash*v>，就像在Perl语言中所做的那样。

Alternately, if you have an SV that is a blessed reference, you can find
out the stash pointer by using:

另外，如果你有一个被blessed的引用，你可以这样获取它的stash指针：

    HV*  SvSTASH(SvRV(SV*));

then use the following to get the package name itself:

然后这样获取它的包名：

    char*  HvNAME(HV* stash);

If you need to bless or re-bless an object you can use the following
function:

如果你需要bless或重复bless一个对象你可以用以下函数：

    SV*  sv_bless(SV*, HV* stash)

where the first argument, an C<SV*>, must be a reference, and the second
argument is a stash.  The returned C<SV*> can now be used in the same way
as any other SV.

第一个参数C<SV*>必须是引用类型，第二次参数是一个stash。返回的C<SV*>可以像其他任何SV一样使用。

For more information on references and blessings, consult L<perlref>.

参考L<perlref>以获取关于引用和bless的更多信息。

=head2 双类型SV

=head2 Double-Typed SVs

Scalar variables normally contain only one type of value, an integer,
double, pointer, or reference.  Perl will automatically convert the
actual scalar data from the stored type into the requested type.

Scalar变量一般只包含一种类型的值，一个整型，一个浮点型，指针或引用。Perl很自动将实际的scalar数据从存储的类型转为需要的类型。

Some scalar variables contain more than one type of scalar data.  For
example, the variable $! contains either the numeric value of C<errno>
or its string equivalent from either strerror or sys_errlist[].

一些scalar变来那个包含一种以上类型的scalar数据。例如，变量$!含了C<errno>的数字值或它的等价字符串（来源于strerror或sys_errlist[]）

To force multiple data values into an SV, you must do two things: use the
sv_set*v routines to add the additional scalar type, then set a flag
so that Perl will believe it contains more than one type of data.  The
four macros to set the flags are:

为了将多个数据存入一个SV，你必须做两件事：用sv_set*v方法添加额外的scalar类型，然后设置一个标记使得Perl认为它包好一种以上类型的数据。
这四个设置标记的宏如下：

	SvIOK_on
	SvNOK_on
	SvPOK_on
	SvROK_on

The particular macro you must use depends on which sv_set*v routine
you called first.  This is because every C<sv_set*v> routine turns on
only the bit for the particular type of data being set, and turns off
all the rest.

究竟使用哪一种宏取决于你调用哪一个sv_set*v方法。这是因为每一个sv_set*v方法都会打开所属数据类型的标记并且关闭其他所有标记。

For example, to create a new Perl variable called "dberror" that contains
both the numeric and descriptive string error values, you could use the
following code:

例如为了创建一个名叫dberror的变量，它既包含错误码的数字也包含描述字符串，你可以使用以下代码：

    extern int  dberror;
    extern char *dberror_list;

    SV* sv = get_sv("dberror", GV_ADD);
    sv_setiv(sv, (IV) dberror);
    sv_setpv(sv, dberror_list[dberror]);
    SvIOK_on(sv);

If the order of C<sv_setiv> and C<sv_setpv> had been reversed, then the
macro C<SvPOK_on> would need to be called instead of C<SvIOK_on>.

如果sv_setiv和sv_setpv的顺序颠倒了，那么你应该使用SvPOK_on这个宏代替SvIOK_on。

=head2 魔法变量

=head2 Magic Variables

[This section still under construction.  Ignore everything here.  Post no
bills.  Everything not permitted is forbidden.]

[这一节仍在建设中。请忽略这里的内容。任何未被允许的行为都是禁止的。]

Any SV may be magical, that is, it has special features that a normal
SV does not have.  These features are stored in the SV structure in a
linked list of C<struct magic>'s, typedef'ed to C<MAGIC>.

任何SV都可能是有魔力的，也就是说它具备一般SV所没有的特性。这些特性被存储在SV结构体中的struct magic链表中，被typedef为MAGIC。

    struct magic {
        MAGIC*      mg_moremagic;
        MGVTBL*     mg_virtual;
        U16         mg_private;
        char        mg_type;
        U8          mg_flags;
        I32         mg_len;
        SV*         mg_obj;
        char*       mg_ptr;
    };

Note this is current as of patchlevel 0, and could change at any time.

注意这个结构定义处于补丁阶段0，将来随时可能会发生改变。

=head2 设置魔法属性

=head2 Assigning Magic

Perl adds magic to an SV using the sv_magic function:

Perl使用sv_magic函数为SV添加魔法性：

  void sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen);

The C<sv> argument is a pointer to the SV that is to acquire a new magical
feature.

参数sv是一个指向需要新的魔法特性的SV的指针。

If C<sv> is not already magical, Perl uses the C<SvUPGRADE> macro to
convert C<sv> to type C<SVt_PVMG>. Perl then continues by adding new magic
to the beginning of the linked list of magical features.  Any prior entry
of the same type of magic is deleted.  Note that this can be overridden,
and multiple instances of the same type of magic can be associated with an
SV.

如果sv当前是没有魔法性的，Perl使用SvUPGRADE宏将sv转型为SVt_PVMG。Perl然后继续添加新的魔法到魔法特性链表的最前端。
任何之前相同类型的魔法特性会被删除。注意这种特性是可以被覆盖的，多个相同类型的魔法特性可以被关联到同一个sv上。

The C<name> and C<namlen> arguments are used to associate a string with
the magic, typically the name of a variable. C<namlen> is stored in the
C<mg_len> field and if C<name> is non-null then either a C<savepvn> copy of
C<name> or C<name> itself is stored in the C<mg_ptr> field, depending on
whether C<namlen> is greater than zero or equal to zero respectively.  As a
special case, if C<(name && namlen == HEf_SVKEY)> then C<name> is assumed
to contain an C<SV*> and is stored as-is with its REFCNT incremented.

name和namlen参数被用于为这种魔法特性关联一个字符串，一般是变量名。namlen储存在mg_len字段。
如果参数name非空，那么一个name的savepvn拷贝或者name自身将会被存储在mg_ptr字段，这取决于namlen是大于0还是等于0。
当name&&namlen == HEf_SVKEY这种特殊情况下，name被认为包含一个SV*且被保存时其引用计数加一。

The sv_magic function uses C<how> to determine which, if any, predefined
"Magic Virtual Table" should be assigned to the C<mg_virtual> field.
See the L<Magic Virtual Tables> section below.  The C<how> argument is also
stored in the C<mg_type> field. The value of C<how> should be chosen
from the set of macros C<PERL_MAGIC_foo> found in F<perl.h>. Note that before
these macros were added, Perl internals used to directly use character
literals, so you may occasionally come across old code or documentation
referring to 'U' magic rather than C<PERL_MAGIC_uvar> for example.

sv_magic函数使用参数how以决定哪一个预定义的"魔法虚表"项将会被赋予mg_virtual字段。
请看下面 '魔法虚表' 一节。how参数同样存在mg_type字段。how的值应该取自PERL_MAGIC_foo系列的宏（定义在perl.h）。
注意在这些宏被添加以前，Perl内部是直接使用字面字符的，例如你偶尔会看到在一些旧的代码或文档中会使用'U'魔法而不是PERL_MAGIC_uvar。

The C<obj> argument is stored in the C<mg_obj> field of the C<MAGIC>
structure.  If it is not the same as the C<sv> argument, the reference
count of the C<obj> object is incremented.  If it is the same, or if
the C<how> argument is C<PERL_MAGIC_arylen>, or if it is a NULL pointer,
then C<obj> is merely stored, without the reference count being incremented.

obj参数存在MAGIC结构体的mg_obj字段。如果他和sv参数不同的话，obj对象的引用计数将会增加。如果是相同的或者参数how是PERL_MAGIC_arylen或者它就是一个空指针，
那么obj就仅仅储存在那，而不会增加引用计数。

See also C<sv_magicext> in L<perlapi> for a more flexible way to add magic
to an SV.

请看perlapi中的sv_magicext一节，那里有跟多更加灵活的向SV添加魔法的方式。

There is also a function to add magic to an C<HV>:

同样有一个用来向HV添加魔法的函数：

    void hv_magic(HV *hv, GV *gv, int how);

This simply calls C<sv_magic> and coerces the C<gv> argument into an C<SV>.

它仅仅是调用了sv_magic，并将gv参数强转为SV。

To remove the magic from an SV, call the function sv_unmagic:

为了移除SV的魔法，调用sv_unmagic：

    int sv_unmagic(SV *sv, int type);

The C<type> argument should be equal to the C<how> value when the C<SV>
was initially made magical.

type参数应该和SV被初始化为有魔法的时候的how参数相同。

However, note that C<sv_unmagic> removes all magic of a certain C<type> from the
C<SV>. If you want to remove only certain magic of a C<type> based on the magic
virtual table, use C<sv_unmagicext> instead:

但是，请注意sv_unmagic会移除SV中type类型所有的魔法。如果你想要基于魔法虚表只移除特定type的魔法，请使用sv_unmagicext以代替它。

    int sv_unmagicext(SV *sv, int type, MGVTBL *vtbl);

=head2 魔法虚表

=head2 Magic Virtual Tables

The C<mg_virtual> field in the C<MAGIC> structure is a pointer to an
C<MGVTBL>, which is a structure of function pointers and stands for
"Magic Virtual Table" to handle the various operations that might be
applied to that variable.

MAGIC结构的mg_virtual字段是一个指向MGVTBL结构的指针，它是一个函数指针结构，代表了"魔法虚表"以处理可能被用于那个变量的各种操作。

The C<MGVTBL> has five (or sometimes eight) pointers to the following
routine types:

MGVTBL有五个（或许有时是八个）指针指向如下函数类型：

    int  (*svt_get)(SV* sv, MAGIC* mg);
    int  (*svt_set)(SV* sv, MAGIC* mg);
    U32  (*svt_len)(SV* sv, MAGIC* mg);
    int  (*svt_clear)(SV* sv, MAGIC* mg);
    int  (*svt_free)(SV* sv, MAGIC* mg);

    int  (*svt_copy)(SV *sv, MAGIC* mg, SV *nsv,
                                          const char *name, I32 namlen);
    int  (*svt_dup)(MAGIC *mg, CLONE_PARAMS *param);
    int  (*svt_local)(SV *nsv, MAGIC *mg);


This MGVTBL structure is set at compile-time in F<perl.h> and there are
currently 32 types.  These different structures contain pointers to various
routines that perform additional actions depending on which function is
being called.

MGVTBL结构是在perl.h文件中编译期设置的，一共有32种类型。这些不同的结构包含了指向各种函数的指针，根据调用函数实现不同的功能。

   Function pointer    Action taken
   ----------------    ------------
   svt_get             Do something before the value of the SV is
                       retrieved.
   svt_set             Do something after the SV is assigned a value.
   svt_len             Report on the SV's length.
   svt_clear           Clear something the SV represents.
   svt_free            Free any extra storage associated with the SV.

   svt_copy            copy tied variable magic to a tied element
   svt_dup             duplicate a magic structure during thread cloning
   svt_local           copy magic to local value during 'local'

   函数指针             行为
   ----------------    ------------
   svt_get             在sv的值被获取到之前做一些事
   svt_set             在sv被赋值之后做一些事
   svt_len             报告sv的长度
   svt_clear           清除sv代表的内容
   svt_free            释放所有和sv关联的额外内存

   svt_copy            将绑定变量的魔法拷贝给绑定元素
   svt_dup             线程克隆时复制魔法结构
   svt_local           在'local'操作时赋值魔法给被local的值

For instance, the MGVTBL structure called C<vtbl_sv> (which corresponds
to an C<mg_type> of C<PERL_MAGIC_sv>) contains:

例如，MGVTBL结构之一vtbl_sv（对应PERL_MAGIC_sv这个mg_type）包含了：

    { magic_get, magic_set, magic_len, 0, 0 }

Thus, when an SV is determined to be magical and of type C<PERL_MAGIC_sv>,
if a get operation is being performed, the routine C<magic_get> is
called.  All the various routines for the various magical types begin
with C<magic_>.  NOTE: the magic routines are not considered part of
the Perl API, and may not be exported by the Perl library.

因此，当一个SV开始有类型为PERL_MAGIC_sv的魔法时，如果发生了一次取值操作，magic_get函数将会被调用。
所有魔法类型的函数都以magic_开头。注意：魔法函数并不是Perl API的一部分，可能不会被Perl库导出。

The last three slots are a recent addition, and for source code
compatibility they are only checked for if one of the three flags
MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most
code can continue declaring a vtable as a 5-element value. These three are
currently used exclusively by the threading code, and are highly subject
to change.

最后三个槽是最近才添加的，为了保持兼容性，只有当mg_flags中MGF_COPY，MGF_DUP，MGF_LOCAL三个位被设置时才需要被检查。
这意味着大多数代码可以继续将vtable申明为一个有5个成员的值。这三个槽被用于线程相关的代码并且很可能会发生变化。

The current kinds of Magic Virtual Tables are:

当前的魔法虚表种类有：

=for comment
This table is generated by regen/mg_vtable.pl.  Any changes made here
will be lost.

=for mg_vtable.pl begin

 mg_type
 (old-style char and macro)   MGVTBL         Type of magic
 --------------------------   ------         -------------
 \0 PERL_MAGIC_sv             vtbl_sv        Special scalar variable
 #  PERL_MAGIC_arylen         vtbl_arylen    Array length ($#ary)
 %  PERL_MAGIC_rhash          (none)         extra data for restricted
                                             hashes
 &  PERL_MAGIC_proto          (none)         my sub prototype CV
 .  PERL_MAGIC_pos            vtbl_pos       pos() lvalue
 :  PERL_MAGIC_symtab         (none)         extra data for symbol
                                             tables
 <  PERL_MAGIC_backref        vtbl_backref   for weak ref data
 @  PERL_MAGIC_arylen_p       (none)         to move arylen out of XPVAV
 B  PERL_MAGIC_bm             vtbl_regexp    Boyer-Moore 
                                             (fast string search)
 c  PERL_MAGIC_overload_table vtbl_ovrld     Holds overload table 
                                             (AMT) on stash
 D  PERL_MAGIC_regdata        vtbl_regdata   Regex match position data 
                                             (@+ and @- vars)
 d  PERL_MAGIC_regdatum       vtbl_regdatum  Regex match position data
                                             element
 E  PERL_MAGIC_env            vtbl_env       %ENV hash
 e  PERL_MAGIC_envelem        vtbl_envelem   %ENV hash element
 f  PERL_MAGIC_fm             vtbl_regexp    Formline 
                                             ('compiled' format)
 g  PERL_MAGIC_regex_global   vtbl_mglob     m//g target
 H  PERL_MAGIC_hints          vtbl_hints     %^H hash
 h  PERL_MAGIC_hintselem      vtbl_hintselem %^H hash element
 I  PERL_MAGIC_isa            vtbl_isa       @ISA array
 i  PERL_MAGIC_isaelem        vtbl_isaelem   @ISA array element
 k  PERL_MAGIC_nkeys          vtbl_nkeys     scalar(keys()) lvalue
 L  PERL_MAGIC_dbfile         (none)         Debugger %_<filename
 l  PERL_MAGIC_dbline         vtbl_dbline    Debugger %_<filename
                                             element
 N  PERL_MAGIC_shared         (none)         Shared between threads
 n  PERL_MAGIC_shared_scalar  (none)         Shared between threads
 o  PERL_MAGIC_collxfrm       vtbl_collxfrm  Locale transformation
 P  PERL_MAGIC_tied           vtbl_pack      Tied array or hash
 p  PERL_MAGIC_tiedelem       vtbl_packelem  Tied array or hash element
 q  PERL_MAGIC_tiedscalar     vtbl_packelem  Tied scalar or handle
 r  PERL_MAGIC_qr             vtbl_regexp    precompiled qr// regex
 S  PERL_MAGIC_sig            (none)         %SIG hash
 s  PERL_MAGIC_sigelem        vtbl_sigelem   %SIG hash element
 t  PERL_MAGIC_taint          vtbl_taint     Taintedness
 U  PERL_MAGIC_uvar           vtbl_uvar      Available for use by
                                             extensions
 u  PERL_MAGIC_uvar_elem      (none)         Reserved for use by
                                             extensions
 V  PERL_MAGIC_vstring        (none)         SV was vstring literal
 v  PERL_MAGIC_vec            vtbl_vec       vec() lvalue
 w  PERL_MAGIC_utf8           vtbl_utf8      Cached UTF-8 information
 x  PERL_MAGIC_substr         vtbl_substr    substr() lvalue
 y  PERL_MAGIC_defelem        vtbl_defelem   Shadow "foreach" iterator
                                             variable / smart parameter
                                             vivification
 ]  PERL_MAGIC_checkcall      vtbl_checkcall inlining/mutation of call
                                             to this CV
 ~  PERL_MAGIC_ext            (none)         Available for use by
                                             extensions

=for mg_vtable.pl end

When an uppercase and lowercase letter both exist in the table, then the
uppercase letter is typically used to represent some kind of composite type
(a list or a hash), and the lowercase letter is used to represent an element
of that composite type. Some internals code makes use of this case
relationship.  However, 'v' and 'V' (vec and v-string) are in no way related.

当一个字母的大小写形式同时出现在表中，那么大写字母一般代表类型（一个列表或一个哈希表），小写字母一般代表那种类型的元素。
一些内部代码使用了这种字母类型的关系。然而，'v'和'V'（vec和v-string）是没有关系的。

The C<PERL_MAGIC_ext> and C<PERL_MAGIC_uvar> magic types are defined
specifically for use by extensions and will not be used by perl itself.
Extensions can use C<PERL_MAGIC_ext> magic to 'attach' private information
to variables (typically objects).  This is especially useful because
there is no way for normal perl code to corrupt this private information
(unlike using extra elements of a hash object).

PERL_MAGIC_ext和PERL_MAGIC_uvar魔法类型被定义用于拓展而不是被Perl自身使用。拓展可以使用PERL_MAGIC_ext魔法来讲私有信息'附着'到变量上（通常是对象）。
这中用法非常有用，因为perl代码没有办法破坏这些私有信息（与使用哈希表的额外元素不同）。

Similarly, C<PERL_MAGIC_uvar> magic can be used much like tie() to call a
C function any time a scalar's value is used or changed.  The C<MAGIC>'s
C<mg_ptr> field points to a C<ufuncs> structure:

与之类似，PERL_MAGIC_uvar魔法可以被用于像tie()一样，当一个scalar的值被使用或改变的时候调用一个C函数。MAGIC结构的mg_ptr字段指向一个ufuncs结构。

    struct ufuncs {
        I32 (*uf_val)(pTHX_ IV, SV*);
        I32 (*uf_set)(pTHX_ IV, SV*);
        IV uf_index;
    };

When the SV is read from or written to, the C<uf_val> or C<uf_set>
function will be called with C<uf_index> as the first arg and a pointer to
the SV as the second.  A simple example of how to add C<PERL_MAGIC_uvar>
magic is shown below.  Note that the ufuncs structure is copied by
sv_magic, so you can safely allocate it on the stack.

当SV被读取或写入的时候，将会调用uf_var或uf_set函数，第一个参数是uf_index，第二个参数是一个指向SV的指针。
一个添加PERL_MAGIC_uvar的简单示例如下所示。注意ufuncs结构被sv_magic拷贝，因此你可以安全得将其分配到栈上。

    void
    Umagic(sv)
        SV *sv;
    PREINIT:
        struct ufuncs uf;
    CODE:
        uf.uf_val   = &my_get_fn;
        uf.uf_set   = &my_set_fn;
        uf.uf_index = 0;
        sv_magic(sv, 0, PERL_MAGIC_uvar, (char*)&uf, sizeof(uf));

Attaching C<PERL_MAGIC_uvar> to arrays is permissible but has no effect.

将PERL_MAGIC_uvar附着到数组上也是允许的，但是没有任何作用。

For hashes there is a specialized hook that gives control over hash
keys (but not values).  This hook calls C<PERL_MAGIC_uvar> 'get' magic
if the "set" function in the C<ufuncs> structure is NULL.  The hook
is activated whenever the hash is accessed with a key specified as
an C<SV> through the functions C<hv_store_ent>, C<hv_fetch_ent>,
C<hv_delete_ent>, and C<hv_exists_ent>.  Accessing the key as a string
through the functions without the C<..._ent> suffix circumvents the
hook.  See L<Hash::Util::FieldHash/GUTS> for a detailed description.

对于哈希表，有一个特殊的手段可以控制哈希表的键。这个技巧调用PERL_MAGIC_uvar的'get'魔法（当ufuncs结构中的"set"函数为NULL的时候）。
当哈希表通过hv_store_ent，hv_fetch_ent，hv_delete_ent和hv_exists_ent几个函数以SV为键访问的时候这个特性将被激活。
当使用不带ent的函数以字符串为键访问的时候则不会激活。请看Hash::Util::FieldHash/GUTS以获得更多细节描述。

Note that because multiple extensions may be using C<PERL_MAGIC_ext>
or C<PERL_MAGIC_uvar> magic, it is important for extensions to take
extra care to avoid conflict.  Typically only using the magic on
objects blessed into the same class as the extension is sufficient.
For C<PERL_MAGIC_ext> magic, it is usually a good idea to define an
C<MGVTBL>, even if all its fields will be C<0>, so that individual
C<MAGIC> pointers can be identified as a particular kind of magic
using their magic virtual table. C<mg_findext> provides an easy way
to do that:

注意因为可能有多个拓展同时使用到PERL_MAGIC_ext和PERL_MAGIC_uvar魔法，避免冲突非常重要。
一般而言只对用被bessed为同一个类的对象使用魔法作为拓展就足够了。对于PERL_MAGIC_ext魔法，最好还是定义一个MGVTBL，
即使它所有的域都是0，这样的话特定的MAGIC指针能通过它们的特殊的魔法虚表标识出来。mg_findext为此提供了一个简单的方式：

    STATIC MGVTBL my_vtbl = { 0, 0, 0, 0, 0, 0, 0, 0 };

    MAGIC *mg;
    if ((mg = mg_findext(sv, PERL_MAGIC_ext, &my_vtbl))) {
        /* this is really ours, not another module's PERL_MAGIC_ext */
        my_priv_data_t *priv = (my_priv_data_t *)mg->mg_ptr;
        ...
    }

Also note that the C<sv_set*()> and C<sv_cat*()> functions described
earlier do B<not> invoke 'set' magic on their targets.  This must
be done by the user either by calling the C<SvSETMAGIC()> macro after
calling these functions, or by using one of the C<sv_set*_mg()> or
C<sv_cat*_mg()> functions.  Similarly, generic C code must call the
C<SvGETMAGIC()> macro to invoke any 'get' magic if they use an SV
obtained from external sources in functions that don't handle magic.
See L<perlapi> for a description of these functions.
For example, calls to the C<sv_cat*()> functions typically need to be
followed by C<SvSETMAGIC()>, but they don't need a prior C<SvGETMAGIC()>
since their implementation handles 'get' magic.

同样注意之前描述的sv_set*()和sv_cat*()函数不会引发它们目标上的'set'魔法。必须要在使用完这些函数后调用SVSETMAGIC()宏，
或者调用sv_set*_mg()湖sv_cat*_mg()函数才能做到。与此类似，C代码在从一些不处理魔法的函数中获取SV时必须要调用SvGETMAGIC()宏以获得'get'魔法。
请参考perapi了解这些函数的信息。
例如，调用sv_cat*()函数一般需要在后面接着调用SvSETMAGIC()，但是他们不需要在之前调用SvGETMAGIC()，因为他们的实现已经处理好'get'魔法了。

=head2 Finding Magic

    MAGIC *mg_find(SV *sv, int type); /* Finds the magic pointer of that
                                       * type */

This routine returns a pointer to a C<MAGIC> structure stored in the SV.
If the SV does not have that magical feature, C<NULL> is returned. If the
SV has multiple instances of that magical feature, the first one will be
returned. C<mg_findext> can be used to find a C<MAGIC> structure of an SV
based on both its magic type and its magic virtual table:

这个方法返回一个SV中指向MAGIC结构的指针。如果SV没有哪个魔法特性则返回NULL。如果SV有这个魔法特性的多个实例将会返回第一个。
mg_findext被用于通过魔法类型和魔法虚表找到SV的MAGIC结构。

    MAGIC *mg_findext(SV *sv, int type, MGVTBL *vtbl);

Also, if the SV passed to C<mg_find> or C<mg_findext> is not of type
SVt_PVMG, Perl may core dump.

同样，如果传入mg_find和mg_findext的SV不输入SVt_PVMG的话，Perl可能会发生内核转储。

    int mg_copy(SV* sv, SV* nsv, const char* key, STRLEN klen);

This routine checks to see what types of magic C<sv> has.  If the mg_type
field is an uppercase letter, then the mg_obj is copied to C<nsv>, but
the mg_type field is changed to be the lowercase letter.

这个函数检查sv的魔法类型。如果mg_type域是大写字符，那么mg_obj被拷贝的nsv，且mg_type域会被转为小写字符。

=head2 理解Tied哈希表和数组的魔法

=head2 Understanding the Magic of Tied Hashes and Arrays


Tied hashes and arrays are magical beasts of the C<PERL_MAGIC_tied>
magic type.

Tied哈希表和数组属于PERL_MAGIC_tied魔法类型。

WARNING: As of the 5.004 release, proper usage of the array and hash
access functions requires understanding a few caveats.  Some
of these caveats are actually considered bugs in the API, to be fixed
in later releases, and are bracketed with [MAYCHANGE] below. If
you find yourself actually applying such information in this section, be
aware that the behavior may change in the future, umm, without warning.

警告：在5.004版本，你需要理解一些注意事项才能正确得使用数组和哈希表的访问函数。一些注意事项其实是API的BUGS，以在后续版本修复，它们在下面会被用[可能改变]括起来。
如果你发现你使用了这部分的信息，请留心它们的行为在将来可能会变化。

The perl tie function associates a variable with an object that implements
the various GET, SET, etc methods.  To perform the equivalent of the perl
tie function from an XSUB, you must mimic this behaviour.  The code below
carries out the necessary steps - firstly it creates a new hash, and then
creates a second hash which it blesses into the class which will implement
the tie methods. Lastly it ties the two hashes together, and returns a
reference to the new tied hash.  Note that the code below does NOT call the
TIEHASH method in the MyTie class -
see L<Calling Perl Routines from within C Programs> for details on how
to do this.

perl tie函数将一个变量关联到一个实现了各种类似GET,SET等方法的对象。为了在XSUB函数中实现与perl tie函数一样的效果，你必须模仿这种行为。
下列代码包含了需要的步骤--首先创建一个新的哈希表，然后创建另一个哈希表并将其bless到一个实现了tie方法的类上面。最后将两个哈希表tie到一起，并返回一个新的tied哈希表。
注意下面的代码没有调用MyTie类中的TIEHASH方法--看 '在C程序中调用Perl函数' 一节以获取更多细节。 

    SV*
    mytie()
    PREINIT:
        HV *hash;
        HV *stash;
        SV *tie;
    CODE:
        hash = newHV();
        tie = newRV_noinc((SV*)newHV());
        stash = gv_stashpv("MyTie", GV_ADD);
        sv_bless(tie, stash);
        hv_magic(hash, (GV*)tie, PERL_MAGIC_tied);
        RETVAL = newRV_noinc(hash);
    OUTPUT:
        RETVAL

The C<av_store> function, when given a tied array argument, merely
copies the magic of the array onto the value to be "stored", using
C<mg_copy>.  It may also return NULL, indicating that the value did not
actually need to be stored in the array.  [MAYCHANGE] After a call to
C<av_store> on a tied array, the caller will usually need to call
C<mg_set(val)> to actually invoke the perl level "STORE" method on the
TIEARRAY object.  If C<av_store> did return NULL, a call to
C<SvREFCNT_dec(val)> will also be usually necessary to avoid a memory
leak. [/MAYCHANGE]

当传给av_store函数一个tied数组参数时，仅仅会使用mg_copy将数组的魔法拷贝到需要存储的值中。
它同样可能返回NULL，表明这个值实际上不需要被储存在数组中。[可能改变]
在对一个tired数组使用av_store后，调用者需要继续调用mg_set(val)以触发对tied数组对象perl级别的STORE方法。
如果av_store返回NULL，则需要调用SvREFCNG_dec(val)以避免内存泄漏。

The previous paragraph is applicable verbatim to tied hash access using the
C<hv_store> and C<hv_store_ent> functions as well.

之前的段落同样适用于tied使用hv_store和hv_store_ent访问哈希表。

C<av_fetch> and the corresponding hash functions C<hv_fetch> and
C<hv_fetch_ent> actually return an undefined mortal value whose magic
has been initialized using C<mg_copy>.  Note the value so returned does not
need to be deallocated, as it is already mortal.  [MAYCHANGE] But you will
need to call C<mg_get()> on the returned value in order to actually invoke
the perl level "FETCH" method on the underlying TIE object.  Similarly,
you may also call C<mg_set()> on the return value after possibly assigning
a suitable value to it using C<sv_setsv>,  which will invoke the "STORE"
method on the TIE object. [/MAYCHANGE]

av_fetch和对应的hv_fetch和hv_fetch_ent实际上返回的是一个用mg_copy初始化的未定义的将死值。
注意这个返回值不需要主动释放，因为它已经是将死的了。
[可能改变]
但是你你需要对这些返回值调用mg_get()以触发对tied对象perl级别的STORE方法。类似，在你对这些返回值使用sv_setsv赋值后可能需要调用mg_set()以出发STORE操作。
[/可能改变]

[MAYCHANGE]
In other words, the array or hash fetch/store functions don't really
fetch and store actual values in the case of tied arrays and hashes.  They
merely call C<mg_copy> to attach magic to the values that were meant to be
"stored" or "fetched".  Later calls to C<mg_get> and C<mg_set> actually
do the job of invoking the TIE methods on the underlying objects.  Thus
the magic mechanism currently implements a kind of lazy access to arrays
and hashes.

Currently (as of perl version 5.004), use of the hash and array access
functions requires the user to be aware of whether they are operating on
"normal" hashes and arrays, or on their tied variants.  The API may be
changed to provide more transparent access to both tied and normal data
types in future versions.
[/MAYCHANGE]

[可能改版]
从另一方面来看，对于tied数组和哈希表来说，fetch/store函数并不是真的获取或存储实际值。
他们仅仅是调用mg_copy来对处理的值施魔法。后续的mg_get和mg_set才是真正调用了TIE方法。
应此这个魔法机制目前实现的是一种对数组和哈希的延时的操作。

当前（对于perl 5.004版本来说），使用哈希表和数组访问方法需要用户清楚他们是在操作‘普通的’还是tied对象。
将来API可能会变化以提供更加透明的访问方式。
[/可能改版]

You would do well to understand that the TIEARRAY and TIEHASH interfaces
are mere sugar to invoke some perl method calls while using the uniform hash
and array syntax.  The use of this sugar imposes some overhead (typically
about two to four extra opcodes per FETCH/STORE operation, in addition to
the creation of all the mortal variables required to invoke the methods).
This overhead will be comparatively small if the TIE methods are themselves
substantial, but if they are only a few statements long, the overhead
will not be insignificant.

你肯定轻松理解到TIEARRAY和TIEHASH接口不过是使用哈希表和数组操作语法来调用一些perl函数的语法糖而已。
使用这些语法糖会导致某些性能损耗。但是如果你的TIE方法非常庞大的话这些损耗是可以忽略不计的。但是如果方法只有几条语句那么长的话，新能损耗就不可以被忽略了。

=head2 本地化改变

=head2 Localizing changes

Perl has a very handy construction

Perl有中非常易用的构造方式：

  {
    local $var = 2;
    ...
  }

This construction is I<approximately> equivalent to

这种方式大概类似于以下代码:

  {
    my $oldvar = $var;
    $var = 2;
    ...
    $var = $oldvar;
  }

The biggest difference is that the first construction would
reinstate the initial value of $var, irrespective of how control exits
the block: C<goto>, C<return>, C<die>/C<eval>, etc. It is a little bit
more efficient as well.

最大的不同是第一种构造将会$var的值将会复原，无论你以什么方式退出代码块。这样会更加高效。

There is a way to achieve a similar task from C via Perl API: create a
I<pseudo-block>, and arrange for some changes to be automatically
undone at the end of it, either explicit, or via a non-local exit (via
die()). A I<block>-like construct is created by a pair of
C<ENTER>/C<LEAVE> macros (see L<perlcall/"Returning a Scalar">).
Such a construct may be created specially for some important localized
task, or an existing one (like boundaries of enclosing Perl
subroutine/block, or an existing pair for freeing TMPs) may be
used. (In the second case the overhead of additional localization must
be almost negligible.) Note that any XSUB is automatically enclosed in
an C<ENTER>/C<LEAVE> pair.

可以在C语言中通过调用Perl API实现类似的功能：创建一个伪代码块，然后进行一些变化并在结尾处自动恢复，无论是主动的还是通过一次非正常退出（通过die函数）。
一个类似于代码块的构建是通过ENTER/LEAVE这一对宏实现的（参见perlcall/"返回一个scalar一节"）。像这样的构造也许会为一些特殊的需要本地化的任务热创建，
亦或本身就存在（比如Perl函数和代码块，or an existing pair for freeing TMPs）。（在第二种情况下不需要多余的本地化。）注意任何XSUB函数都被自动包含在一对ENTER/LEAVE对中。

Inside such a I<pseudo-block> the following service is available:

在这样一个伪代码块中一下服务是可用的：

=over 4

=item C<SAVEINT(int i)>

=item C<SAVEIV(IV i)>

=item C<SAVEI32(I32 i)>

=item C<SAVELONG(long i)>

These macros arrange things to restore the value of integer variable
C<i> at the end of enclosing I<pseudo-block>.

这些宏会将整数i的值在代码块结束后恢复。

=item C<SAVESPTR(s)>

=item C<SAVEPPTR(p)>

These macros arrange things to restore the value of pointers C<s> and
C<p>. C<s> must be a pointer of a type which survives conversion to
C<SV*> and back, C<p> should be able to survive conversion to C<char*>
and back.

这些宏会将指针s和p的值恢复。s必须满足可以被强转为SV*并复原，p必须满足可以被强转为char*并复原。

=item C<SAVEFREESV(SV *sv)>

The refcount of C<sv> would be decremented at the end of
I<pseudo-block>.  This is similar to C<sv_2mortal> in that it is also a
mechanism for doing a delayed C<SvREFCNT_dec>.  However, while C<sv_2mortal>
extends the lifetime of C<sv> until the beginning of the next statement,
C<SAVEFREESV> extends it until the end of the enclosing scope.  These
lifetimes can be wildly different.

sv的引用计数将在代码框的几位减一。这和sv_2mortal类似都是SvREFCNT_dec的延时操作。然而，sv_2mortal将sv的生命延长到下一条语句的开始，SAVEFREESV则延长到代码块的结束。
这些生命周期可能完全不同。

Also compare C<SAVEMORTALIZESV>.

=item C<SAVEMORTALIZESV(SV *sv)>

Just like C<SAVEFREESV>, but mortalizes C<sv> at the end of the current
scope instead of decrementing its reference count.  This usually has the
effect of keeping C<sv> alive until the statement that called the currently
live scope has finished executing.

和SAVEFREESV一样，但是在代码块的结束处将sv设置为将死的而不减少它的引用计数。这通常会使得sv生存到调用这个代码块的语句运行结束。

=item C<SAVEFREEOP(OP *op)>

The C<OP *> is op_free()ed at the end of I<pseudo-block>.

OP* 将在代码块末尾处被op_free()。

=item C<SAVEFREEPV(p)>

The chunk of memory which is pointed to by C<p> is Safefree()ed at the
end of I<pseudo-block>.

p指针指向的内存块将在代码块末尾处被Safefree()。

=item C<SAVECLEARSV(SV *sv)>

Clears a slot in the current scratchpad which corresponds to C<sv> at
the end of I<pseudo-block>.

在代码块结尾处清除表示一个sv的暂存器中的槽。

=item C<SAVEDELETE(HV *hv, char *key, I32 length)>

The key C<key> of C<hv> is deleted at the end of I<pseudo-block>. The
string pointed to by C<key> is Safefree()ed.  If one has a I<key> in
short-lived storage, the corresponding string may be reallocated like
this:

hv的键key在代码块的结尾处删除。key指向的字符串被safefree()掉。如果key被保存在短期储存空间中，对应的字符串可以这样重分配。

  SAVEDELETE(PL_defstash, savepv(tmpbuf), strlen(tmpbuf));

=item C<SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void *p)>

At the end of I<pseudo-block> the function C<f> is called with the
only argument C<p>.

在代码块结尾，将调用f并传入参数p。

=item C<SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void *p)>

At the end of I<pseudo-block> the function C<f> is called with the
implicit context argument (if any), and C<p>.

在代码块结尾，将调用f，隐式传入上下文变量（如果有的话）和p。

=item C<SAVESTACK_POS()>

The current offset on the Perl internal stack (cf. C<SP>) is restored
at the end of I<pseudo-block>.

在代码块结尾，Perl内部栈偏移（cf。 SP）将被恢复。

=back

The following API list contains functions, thus one needs to
provide pointers to the modifiable data explicitly (either C pointers,
or Perlish C<GV *>s).  Where the above macros take C<int>, a similar
function takes C<int *>.

以下API列表包含函数，应此需要显式提供指向可变数据的指针（C指针或者Perlish的GV*）。比如如果以上的宏传入int的话，那么一个相似的函数就要传入int*。

=over 4

=item C<SV* save_scalar(GV *gv)>

Equivalent to Perl code C<local $gv>.

和Perl代码local $gv一样。

=item C<AV* save_ary(GV *gv)>

=item C<HV* save_hash(GV *gv)>

Similar to C<save_scalar>, but localize C<@gv> and C<%gv>.

和save_scalar一样，但是会本地化@gv和%gv。

=item C<void save_item(SV *item)>

Duplicates the current value of C<SV>, on the exit from the current
C<ENTER>/C<LEAVE> I<pseudo-block> will restore the value of C<SV>
using the stored value. It doesn't handle magic. Use C<save_scalar> if
magic is affected.

复制当前SV的值，当从ENTER/LEAVE代码块中退出时会使用保存下来的值恢复SV。
它不会处理魔法。如果需要处理魔法的话使用save_scalar。

=item C<void save_list(SV **sarg, I32 maxsarg)>

A variant of C<save_item> which takes multiple arguments via an array
C<sarg> of C<SV*> of length C<maxsarg>.

save_item的变种，通过sary数组传入多个SV*以及其长度maxsarg。

=item C<SV* save_svref(SV **sptr)>

Similar to C<save_scalar>, but will reinstate an C<SV *>.

和save_scalar类似，但是会恢复SV*。

=item C<void save_aptr(AV **aptr)>

=item C<void save_hptr(HV **hptr)>

Similar to C<save_svref>, but localize C<AV *> and C<HV *>.

和save_svref类似，但是将本地化AV*和HV*。

=back

The C<Alias> module implements localization of the basic types within the
I<caller's scope>.  People who are interested in how to localize things in
the containing scope should take a look there too.

Alias模块实现了在调用者域中本地化基本类型。对如何在包含域中本地化数据的人可以看下。

=head2 函数

=head1 Subroutines

=head2 XSUBs and the Argument Stack

XSUB函数如参数栈

The XSUB mechanism is a simple way for Perl programs to access C subroutines.
An XSUB routine will have a stack that contains the arguments from the Perl
program, and a way to map from the Perl data structures to a C equivalent.

XSUB机制是Perl程序访问C函数的一种简单的方法。一个XSUB函数有一个包含了从Perl程序传入的参数的栈，
和一种将Perl数据结构映射到对等的C结构的方法。

The stack arguments are accessible through the C<ST(n)> macro, which returns
the C<n>'th stack argument.  Argument 0 is the first argument passed in the
Perl subroutine call.  These arguments are C<SV*>, and can be used anywhere
an C<SV*> is used.

参数栈可以通过ST(n)宏访问到，其返回第n个栈的参数。第0参数是Perl函数传入的第一个参数。这些参数类型为SV*，
可以被用于任何SV*被使用的地方。

Most of the time, output from the C routine can be handled through use of
the RETVAL and OUTPUT directives.  However, there are some cases where the
argument stack is not already long enough to handle all the return values.
An example is the POSIX tzname() call, which takes no arguments, but returns
two, the local time zone's standard and summer time abbreviations.

大多数情况下，C函数的的输出可以用RETVAL和OUTPUT指令处理。然而，在某些情况下参数栈不足以处理所有的返回值。
比如POSIX tzname()调用，它没有任何参数，但是却返回两个参数：本地时区和夏令2时的缩写。

To handle this situation, the PPCODE directive is used and the stack is
extended using the macro:

为了处理这种情况，需要使用PPCODE指令并且使用如下宏来扩展栈大小：

    EXTEND(SP, num);

where C<SP> is the macro that represents the local copy of the stack pointer,
and C<num> is the number of elements the stack should be extended by.

SP是代表当前栈指针的本地拷贝，num是栈应当拓展的元素数量。

Now that there is room on the stack, values can be pushed on it using C<PUSHs>
macro. The pushed values will often need to be "mortal" (See
L</Reference Counts and Mortality>):

现在栈上又有空间了，可以使用PUSHs宏向栈上压入值。压入的值通常是'将死的'。

    PUSHs(sv_2mortal(newSViv(an_integer)))
    PUSHs(sv_2mortal(newSVuv(an_unsigned_integer)))
    PUSHs(sv_2mortal(newSVnv(a_double)))
    PUSHs(sv_2mortal(newSVpv("Some String",0)))
    /* Although the last example is better written as the more
     * efficient: */
    PUSHs(newSVpvs_flags("Some String", SVs_TEMP))

And now the Perl program calling C<tzname>, the two values will be assigned
as in:

现在当Perl程序调用tzname时，将用一下方式赋两个值：

    ($standard_abbrev, $summer_abbrev) = POSIX::tzname;

An alternate (and possibly simpler) method to pushing values on the stack is
to use the macro:

另一种压栈的方式（可能更加简单）是使用如下宏：

    XPUSHs(SV*)

This macro automatically adjusts the stack for you, if needed.  Thus, you
do not need to call C<EXTEND> to extend the stack.

如果有必要的话，这个宏将自适应栈空间。因此你不需要调用EXTEND来拓展栈空间了。

Despite their suggestions in earlier versions of this document the macros
C<(X)PUSH[iunp]> are I<not> suited to XSUBs which return multiple results.
For that, either stick to the C<(X)PUSHs> macros shown above, or use the new
C<m(X)PUSH[iunp]> macros instead; see L</Putting a C value on Perl stack>.

尽管在该文档的早期版本中建议(X)PUSH[iunp]不适用于返回多个值的XSUB函数。
因此，要么坚持使用上面提到的(X)PUSHs宏，要么改为使用新的m(X)PUSH[iunp]宏；
参见 '向一个Perl栈上压如一个C的值'。

For more information, consult L<perlxs> and L<perlxstut>.

请参考perlxs和perlxstut以获取更多信息。

=head2 和XSUB函数相关的自动载入

=head2 Autoloading with XSUBs

If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the
fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable
of the XSUB's package.

如果AUTOLOAD方法的对象是一个XSUB，那么和Perl函数一样，Perl会将自动载入的函数全名放置到XSUB所在包的$AUTOLOAD变量中。

But it also puts the same information in certain fields of the XSUB itself:

但是它会将同样的信息放到XSUB自身的某些字段中。

    HV *stash           = CvSTASH(cv);
    const char *subname = SvPVX(cv);
    STRLEN name_length  = SvCUR(cv); /* in bytes */
    U32 is_utf8         = SvUTF8(cv);

C<SvPVX(cv)> contains just the sub name itself, not including the package.
For an AUTOLOAD routine in UNIVERSAL or one of its superclasses,
C<CvSTASH(cv)> returns NULL during a method call on a nonexistent package.

SvPVX(cv)包含了函数自己的名字，不包括包名。对于在UNIVERSAL或其父类中的AUTOLOAD方法来说，
当调用一个不存在道德包的方法时CvSTASH(cv)放回NULL。

B<Note>: Setting $AUTOLOAD stopped working in 5.6.1, which did not support
XS AUTOLOAD subs at all.  Perl 5.8.0 introduced the use of fields in the
XSUB itself.  Perl 5.16.0 restored the setting of $AUTOLOAD.  If you need
to support 5.8-5.14, use the XSUB's fields.

注意：5.6.1版本不支持设置$AUTOLOAD，这个版本压根不支持XS AUTOLOAD函数。Perl 5.8.0引入和XSUB自身字段的使用。
Perl 5.16.0恢复了$AUTOLOAD的设置。如果你需要支持5.18-5.14，使用XSUB函数的字段。

=head2 从C程序中调用Perl函数。

=head2 Calling Perl Routines from within C Programs

There are four routines that can be used to call a Perl subroutine from
within a C program.  These four are:

有四个函数可以用来从C程序中调用Perl函数。这四个分别为：

    I32  call_sv(SV*, I32);
    I32  call_pv(const char*, I32);
    I32  call_method(const char*, I32);
    I32  call_argv(const char*, I32, char**);

The routine most often used is C<call_sv>.  The C<SV*> argument
contains either the name of the Perl subroutine to be called, or a
reference to the subroutine.  The second argument consists of flags
that control the context in which the subroutine is called, whether
or not the subroutine is being passed arguments, how errors should be
trapped, and how to treat return values.

最常用的函数是C<call_sv>。C<SV*>参数包含了需要调用的Perl函数的函数名或是函数引用。
第二个参数是控制被调用函数上下文的标记，比如这个函数有没有参数，错误应该如何处理以及如何处理返回值。

All four routines return the number of arguments that the subroutine returned
on the Perl stack.

所有的函数都返回perl函数返回到Perl栈上的参数的个数。

These routines used to be called C<perl_call_sv>, etc., before Perl v5.6.0,
but those names are now deprecated; macros of the same name are provided for
compatibility.

在perl5.6.0之前，这些函数曾经被成为C<perl_call_sv>等等。但是这些名字现在废弃了；并且提供了同名的宏以保持兼容。

When using any of these routines (except C<call_argv>), the programmer
must manipulate the Perl stack.  These include the following macros and
functions:

使用任何这些函数时（除了C<call_argv>），程序员必须管理Perl的栈。包括以下宏和函数。

    dSP
    SP
    PUSHMARK()
    PUTBACK
    SPAGAIN
    ENTER
    SAVETMPS
    FREETMPS
    LEAVE
    XPUSH*()
    POP*()

For a detailed description of calling conventions from C to Perl,
consult L<perlcall>.

请参见L<perlcall>以获得更多关于用C调用Perl函数的规则。

=head2 内存分配

=head2 Memory Allocation

=head3 分配

=head3 Allocation

All memory meant to be used with the Perl API functions should be manipulated
using the macros described in this section.  The macros provide the necessary
transparency between differences in the actual malloc implementation that is
used within perl.

当使用Perl API函数时所有的内存管理都必须通过该节定义的宏进行。这些宏对Perl内部内存分配实现上的不同提供了封装。

It is suggested that you enable the version of malloc that is distributed
with Perl.  It keeps pools of various sizes of unallocated memory in
order to satisfy allocation requests more quickly.  However, on some
platforms, it may cause spurious malloc or free errors.

推荐打开随Perl发布的malloc版本。其将会管理各种大小未分配的内存块以更快得满足内存分配的需要。
然而在某些平台它会导致虚假的分配和释放错误。

The following three macros are used to initially allocate memory :

一下三个宏用于初始化分配的内存：

    Newx(pointer, number, type);
    Newxc(pointer, number, type, cast);
    Newxz(pointer, number, type);

The first argument C<pointer> should be the name of a variable that will
point to the newly allocated memory.

第一个参数C<pointer>应该为指向最新分配内存的变量的名称。

The second and third arguments C<number> and C<type> specify how many of
the specified type of data structure should be allocated.  The argument
C<type> is passed to C<sizeof>.  The final argument to C<Newxc>, C<cast>,
should be used if the C<pointer> argument is different from the C<type>
argument.

第二个和第三个参数C<number>和C<type>表明多少个指定类型的内存需要分配。C<type>参数将被传给C<sizeof>。
C<Newxc>的最后一个参数C<cast>在C<pointer>参数和C<type>参数不同的时候将被使用。

Unlike the C<Newx> and C<Newxc> macros, the C<Newxz> macro calls C<memzero>
to zero out all the newly allocated memory.

和C<Newx>和C<Newxc>不同的是C<Newxz>宏调用C<memzero>将所有新分配内存清0。

=head3 再分配

=head3 Reallocation

    Renew(pointer, number, type);
    Renewc(pointer, number, type, cast);
    Safefree(pointer)

These three macros are used to change a memory buffer size or to free a
piece of memory no longer needed.  The arguments to C<Renew> and C<Renewc>
match those of C<New> and C<Newc> with the exception of not needing the
"magic cookie" argument.

这三个宏被用于改变一块内存缓冲区的大小或释放不再需要的内存。C<Renew>和C<Renewc>的参数
匹配C<New>和C<NewC>，除了不许要"魔法cookie"以外。

=head3 移动

=head3 Moving


    Move(source, dest, number, type);
    Copy(source, dest, number, type);
    Zero(dest, number, type);

These three macros are used to move, copy, or zero out previously allocated
memory.  The C<source> and C<dest> arguments point to the source and
destination starting points.  Perl will move, copy, or zero out C<number>
instances of the size of the C<type> data structure (using the C<sizeof>
function).

这三个宏被用于移动，拷贝或清零之前分配的内存。C<source>和C<dest>参数指向了起始指针的源和目的地址。
Perl将会移动，拷贝或清零C<number>快和C<type>大小一致的内存区域。

=head2 PerlIO
=head2 PerlIO

The most recent development releases of Perl have been experimenting with
removing Perl's dependency on the "normal" standard I/O suite and allowing
other stdio implementations to be used.  This involves creating a new
abstraction layer that then calls whichever implementation of stdio Perl
was compiled with.  All XSUBs should now use the functions in the PerlIO
abstraction layer and not make any assumptions about what kind of stdio
is being used.

最近开发的Perl版本开始移除Perl对"普通"的标准I/O实现的依赖（实验性地）并允使用许其他标准io实现。
这导致了实现一个抽象层然后再调用具体被编译的标准io。所有的XSUB函数都应该使用PerlIO抽象层，而不应该对具体使用的标准IO做任何假设。

For a complete description of the PerlIO abstraction, consult L<perlapio>.

对PerlIO抽象层的完整描述请参考L<perlapio>。

=head2 向Perl栈上放置一个C值 
=head2 Putting a C value on Perl stack

A lot of opcodes (this is an elementary operation in the internal perl
stack machine) put an SV* on the stack. However, as an optimization
the corresponding SV is (usually) not recreated each time. The opcodes
reuse specially assigned SVs (I<target>s) which are (as a corollary)
not constantly freed/created.

很多opcodes（在Perl内部的栈机器中这算是一个基本操作）会将一个SV*放置到栈上。
然而，作为一种优化，相应的SV（通常）不会每次都重复创建。opcodes会重用那些不会经常创建或释放的SV们（I<target>s）

Each of the targets is created only once (but see
L<Scratchpads and recursion> below), and when an opcode needs to put
an integer, a double, or a string on stack, it just sets the
corresponding parts of its I<target> and puts the I<target> on stack.

每一个目标只会创建一次（请看下面的L<暂存器与递归>一节），当一个opcode需要向栈上放置一个整形，双精度浮点型或字符串时，
它仅需要设置它I<target>的相应部分并将I<target>放置到栈上。

The macro to put this target on stack is C<PUSHTARG>, and it is
directly used in some opcodes, as well as indirectly in zillions of
others, which use it via C<(X)PUSH[iunp]>.

向栈上放置target的宏是C<PUSHTARG>，一些opcodes之间使用了这个宏，同样还有很多通过C<(X)PUSH[iump]>间接使用的例子。

Because the target is reused, you must be careful when pushing multiple
values on the stack. The following code will not do what you think:

由于target被重用，当你需要往栈上压多个值的时候必须小心。以下代码不会以你想象地那样工作：

    XPUSHi(10);
    XPUSHi(20);

This translates as "set C<TARG> to 10, push a pointer to C<TARG> onto
the stack; set C<TARG> to 20, push a pointer to C<TARG> onto the stack".
At the end of the operation, the stack does not contain the values 10
and 20, but actually contains two pointers to C<TARG>, which we have set
to 20.

这样写会被解释为“先将C<TARG>设置为10，然后将一个指向C<TARG>的指针压到栈中；将C<TARG>设置为20，再将指向它的指针压到栈中”。
操作完成后，栈中不会包含10和20，而是两个指向C<TARG>的指针，其值为20。

If you need to push multiple different values then you should either use
the C<(X)PUSHs> macros, or else use the new C<m(X)PUSH[iunp]> macros,
none of which make use of C<TARG>.  The C<(X)PUSHs> macros simply push an
SV* on the stack, which, as noted under L</XSUBs and the Argument Stack>,
will often need to be "mortal".  The new C<m(X)PUSH[iunp]> macros make
this a little easier to achieve by creating a new mortal for you (via
C<(X)PUSHmortal>), pushing that onto the stack (extending it if necessary
in the case of the C<mXPUSH[iunp]> macros), and then setting its value.
Thus, instead of writing this to "fix" the example above:

如果你需要将多个不同的值压栈，应该使用C<(X)PUSHs>宏或者新的C<m(X)PUSH[iunp]>宏，这些都不会使用C<TARG>。
C<(X)PUSHs>只会向栈上压一个SV*，如L</XSUBs和参数栈>一节中提到的，它通常应当是“将死的”。
新的C<m(X)PUSH[iunp]>宏简化了该操作，它会创建一个新的将死变量（通过C<(X)PUSHmortal>），
将其压到栈上（如果必要的话会拓展栈），并设置其值。应次我们需要这样修改上面的例子：

    XPUSHs(sv_2mortal(newSViv(10)))
    XPUSHs(sv_2mortal(newSViv(20)))

you can simply write:

也可以简单地写为：

    mXPUSHi(10)
    mXPUSHi(20)

On a related note, if you do use C<(X)PUSH[iunp]>, then you're going to
need a C<dTARG> in your variable declarations so that the C<*PUSH*>
macros can make use of the local variable C<TARG>.  See also C<dTARGET>
and C<dXSTARG>.

补充：如果你使用C<(X)PUSH[iunp]>，那么你需要申明一个C<dTAEG>，这样C<*PUSH*>宏就可以使用本地的变量C<TARG>。
参见C<dTARGET>和C<dXSTARG>。

=head2 暂存器

=head2 Scratchpads

The question remains on when the SVs which are I<target>s for opcodes
are created. The answer is that they are created when the current
unit--a subroutine or a file (for opcodes for statements outside of
subroutines)--is compiled. During this time a special anonymous Perl
array is created, which is called a scratchpad for the current unit.

这里有一个遗留问题：作为opcodes的I<target>s的SVs是什么时候创建的。
答案是它们是在所处单元--一个子例程或一个文件--被编译的时候。
在此期间一个特殊的匿名Perl数组被创建出来，在当前单元中被称作暂存器。

A scratchpad keeps SVs which are lexicals for the current unit and are
targets for opcodes. One can deduce that an SV lives on a scratchpad
by looking on its flags: lexicals have C<SVs_PADMY> set, and
I<target>s have C<SVs_PADTMP> set.

一个暂存器会将作为opcodes的当前单元中的词法域的target保存起来。
你可以通过SV上的标识判断它是否在暂存器上：词法域变量的C<SVs_PADMY>字段将被设置，
I<target>s的C<SVs_PADTMP>字段将被设置。

The correspondence between OPs and I<target>s is not 1-to-1. Different
OPs in the compile tree of the unit can use the same target, if this
would not conflict with the expected life of the temporary.

OPs和I<target>s并不是一一对应的关系。编译树上同一单元的不同OPs可以使用相同的target，
如果这和它的生命周期不矛盾的话。

=head2 暂存器与递归

=head2 Scratchpads and recursion

In fact it is not 100% true that a compiled unit contains a pointer to
the scratchpad AV. In fact it contains a pointer to an AV of
(initially) one element, and this element is the scratchpad AV. Why do
we need an extra level of indirection?

其实一个编译单元包含一个指向暂存器AV的指针的说法并不完全正确。
实际上它包含一个指向一个（被初始化为）只有一个元素的AV的指针，而这个元素才是暂存器AV。
为什么我们需要另一层的间接跳转呢？

The answer is B<recursion>, and maybe B<threads>. Both
these can create several execution pointers going into the same
subroutine. For the subroutine-child not write over the temporaries
for the subroutine-parent (lifespan of which covers the call to the
child), the parent and the child should have different
scratchpads. (I<And> the lexicals should be separate anyway!)

这个答案是B<递归>，可能也有B<线程>。它们都会为同一个子例程创建多个运行时的指针。
为了让被递归调用的子子例程不会覆盖父子例程的临时变量（其生命周期包含了对子子例程的调用），父子例程都应该有自己的暂存器。
(I<并且>此法域的情况应该是另一种情况！)

So each subroutine is born with an array of scratchpads (of length 1).
On each entry to the subroutine it is checked that the current
depth of the recursion is not more than the length of this array, and
if it is, new scratchpad is created and pushed into the array.

每一个子例程的创建都伴随着一个长度为1的暂存器数组。在子例程的每一个入口点都会检查当前的递归深度是否比数组的长度长，
如果是的话，将创建新的暂存器并将其存如数组中。

The I<target>s on this scratchpad are C<undef>s, but they are already
marked with correct flags.

暂存器中的I<target>s都是C<undef>s，但是它们已经被设置了正确额标记。

=head1 编译的代码

=head1 Compiled code

=head2 代码树

=head2 Code tree

Here we describe the internal form your code is converted to by
Perl. Start with a simple example:

这里我们描述Perl将你的代码转换程的内部形式。以这个简单的例子开始：

  $a = $b + $c;

This is converted to a tree similar to this one:

它被转换为类似于下面这棵树的样子：

             assign-to
           /           \
          +             $a
        /   \
      $b     $c

(but slightly more complicated).  This tree reflects the way Perl
parsed your code, but has nothing to do with the execution order.
There is an additional "thread" going through the nodes of the tree
which shows the order of execution of the nodes.  In our simplified
example above it looks like:

（稍微有些复杂）。这课树反映了Perl parse你的代码的方式，但是和运行顺序无关。
另有一个额外的“线程”遍历这棵树以展现节点执行的顺序。在我们简化的例子中它看起来像这样：

     $b ---> $c ---> + ---> $a ---> assign-to

But with the actual compile tree for C<$a = $b + $c> it is different:
some nodes I<optimized away>.  As a corollary, though the actual tree
contains more nodes than our simplified example, the execution order
is the same as in our example.

但是C<$a = $b + $c>实际的编译树是有所不同的：一些节点被优化掉。结果尽管实际的树包含了比我们简化的树更多的节点，
但是执行的顺序还是一样的。

=head2 研究这颗树

=head2 Examining the tree

If you have your perl compiled for debugging (usually done with
C<-DDEBUGGING> on the C<Configure> command line), you may examine the
compiled tree by specifying C<-Dx> on the Perl command line.  The
output takes several lines per node, and for C<$b+$c> it looks like
this:

如果你的perl以调试模式编译（通常通过打开C<Configure>命令行的C<-DDEBUGGING>开关来设置），
你可以通过设置perl命令行的C<-Dx>来研究编译树。每一个节点都会打印多行输出，C<$b+$c>的结果看起来像这样：

    5           TYPE = add  ===> 6
                TARG = 1
                FLAGS = (SCALAR,KIDS)
                {
                    TYPE = null  ===> (4)
                      (was rv2sv)
                    FLAGS = (SCALAR,KIDS)
                    {
    3                   TYPE = gvsv  ===> 4
                        FLAGS = (SCALAR)
                        GV = main::b
                    }
                }
                {
                    TYPE = null  ===> (5)
                      (was rv2sv)
                    FLAGS = (SCALAR,KIDS)
                    {
    4                   TYPE = gvsv  ===> 5
                        FLAGS = (SCALAR)
                        GV = main::c
                    }
                }

This tree has 5 nodes (one per C<TYPE> specifier), only 3 of them are
not optimized away (one per number in the left column).  The immediate
children of the given node correspond to C<{}> pairs on the same level
of indentation, thus this listing corresponds to the tree:

这棵树有5个节点（每个节点有一个C<TYPE>标识），只有三个没有被优化掉（每个节点在左边一列都有一个数字）。
给定节点的子节点都包含在相同缩进的C<{}>对中，以下为对应的树：

                   add
                 /     \
               null    null
                |       |
               gvsv    gvsv

The execution order is indicated by C<===E<gt>> marks, thus it is C<3
4 5 6> (node C<6> is not included into above listing), i.e.,
C<gvsv gvsv add whatever>.

执行顺序是通过C<===E<gt>>标识的，为C<3 4 5 6>（节点C<6>没有被包括进来），即：C<gvsv gvsv add whatever>。

Each of these nodes represents an op, a fundamental operation inside the
Perl core. The code which implements each operation can be found in the
F<pp*.c> files; the function which implements the op with type C<gvsv>
is C<pp_gvsv>, and so on. As the tree above shows, different ops have
different numbers of children: C<add> is a binary operator, as one would
expect, and so has two children. To accommodate the various different
numbers of children, there are various types of op data structure, and
they link together in different ways.

每个树节点带便一个op，Perl核心中的一种基础操作。每一个操作的实现都可以在F<pp*.c>文件中找到；
实现类型为C<gvsv>的op的函数为C<pp_gvsv>，等等。如上面树所表示的，不同的op有不同数量的子节点：
C<add>是一个二元节点，有各种类型的op数据结构，它们通过不同的方式链接起来。

The simplest type of op structure is C<OP>: this has no children. Unary
operators, C<UNOP>s, have one child, and this is pointed to by the
C<op_first> field. Binary operators (C<BINOP>s) have not only an
C<op_first> field but also an C<op_last> field. The most complex type of
op is a C<LISTOP>, which has any number of children. In this case, the
first child is pointed to by C<op_first> and the last child by
C<op_last>. The children in between can be found by iteratively
following the C<op_sibling> pointer from the first child to the last.

最简单的op结构是c<OP>；它没有子节点。一元操作C<UNOP>s通过C<op_first>字段指向唯一的一个子节点。
二元操作C<BINOP>s有C<op_first>和C<op_last>两个字段。最复杂的操作类型为C<LISTOP>，它有任意数量的子节点。
在这种情况下，C<op_first>指向第一个字节点，C<op_last>指向最后一个子节点。
之间的字节点可以递归地通过C<op_sibling>指针从第一个开始到最后一个字节点获取到。

There are also two other op types: a C<PMOP> holds a regular expression,
and has no children, and a C<LOOP> may or may not have children. If the
C<op_children> field is non-zero, it behaves like a C<LISTOP>. To
complicate matters, if a C<UNOP> is actually a C<null> op after
optimization (see L</Compile pass 2: context propagation>) it will still
have children in accordance with its former type.

同样有另外两种op类型：C<PMOP>保存一个正则表达式，它没有子节点。C<LOOP>有或没有字节点。
如果C<op_children>字段为非0，那么它就像C<LISTOP>。
让事情变得更复杂的是：如果一个C<UNOP>优化后是一个C<null>op（请参见L</第二轮编译：上下文传递>）它仍然根据它之前的类型拥有字节点。

Another way to examine the tree is to use a compiler back-end module, such
as L<B::Concise>.

另一种检查树的方式是使用编译器后端模块，比如L<B::Concise>。

=head2 编译阶段1：检查子例程

=head2 Compile pass 1: check routines

The tree is created by the compiler while I<yacc> code feeds it
the constructions it recognizes. Since I<yacc> works bottom-up, so does
the first pass of perl compilation.

伴随着I<yacc>代码将识别后的结构传给编译器，树被逐渐创建出来。由于I<yacc>是自底向上的，
所以perl编译的第一次遍历阶段也是如此。

What makes this pass interesting for perl developers is that some
optimization may be performed on this pass.  This is optimization by
so-called "check routines".  The correspondence between node names
and corresponding check routines is described in F<opcode.pl> (do not
forget to run C<make regen_headers> if you modify this file).

使得perl开发者产生兴趣的是此阶段做的被称作"检查自例程"的优化。
节点名称和对应的”检查子例程“在F<opcode.pl>中描述（如果你修改了这个文件，不要忘记运行C<make regen_headers>）。

A check routine is called when the node is fully constructed except
for the execution-order thread.  Since at this time there are no
back-links to the currently constructed node, one can do most any
operation to the top-level node, including freeing it and/or creating
new nodes above/below it.

当一个节点完全构建完成后将会运行一个检查子例程。由于此时并没有对当前节点的反向链接，
你可以对顶级节点做几乎任何操作，包括释放掉它或者在它之上或之下创建新的节点。

The check routine returns the node which should be inserted into the
tree (if the top-level node was not modified, check routine returns
its argument).

检查子例程返回需要插入到树中的节点（如果顶级节点没有被修改，检查子例程直接返回它的参数）。

By convention, check routines have names C<ck_*>. They are usually
called from C<new*OP> subroutines (or C<convert>) (which in turn are
called from F<perly.y>).

按约定，检查子例程命名为C<ck_*>。它们通常被C<new*OP>子例程（或C<convert>）（其间接被从F<perly.y>调用）调用。

=head2 编译阶段1a: 常量折叠

=head2 Compile pass 1a: constant folding

Immediately after the check routine is called the returned node is
checked for being compile-time executable.  If it is (the value is
judged to be constant) it is immediately executed, and a I<constant>
node with the "return value" of the corresponding subtree is
substituted instead.  The subtree is deleted.

在检查子例程被调用后会立刻检查返回的节点是否可以在编译期运行。
如果是（其值被判断是常量）它会被立刻执行，并且相应子树被替换为它的返回值对应的常量节点。
子树随后被删除。

If constant folding was not performed, the execution-order thread is
created.

如果常量折叠没有发生，执行线程将被创建。

=head2 编译阶段2： 上下文传递

=head2 Compile pass 2: context propagation

When a context for a part of compile tree is known, it is propagated
down through the tree.  At this time the context can have 5 values
(instead of 2 for runtime context): void, boolean, scalar, list, and
lvalue.  In contrast with the pass 1 this pass is processed from top
to bottom: a node's context determines the context for its children.

当一个编译树的上下文已知时，它将沿着树传递下去。此时上下文可以有五个值（和运行上下文的2个值有所区别）：
void，boolean，scalar，list，和lvalue。
与第一阶段不同的是这一阶段的遍历方向是自顶向下：节点的上下文决定了其子节点的上下文。

Additional context-dependent optimizations are performed at this time.
Since at this moment the compile tree contains back-references (via
"thread" pointers), nodes cannot be free()d now.  To allow
optimized-away nodes at this stage, such nodes are null()ified instead
of free()ing (i.e. their type is changed to OP_NULL).

额外的上下文相关的优化将在此时进行。从此时起编译树开始包含反向引用（通过"线程"指针），
节点不再可以释放了。为了在这个阶段优化掉节点，这些节点被null()掉而不是释放掉（例如，它们的类型变为OP_NULL）。

=head2 编译阶段3：窥孔优化

=head2 Compile pass 3: peephole optimization

After the compile tree for a subroutine (or for an C<eval> or a file)
is created, an additional pass over the code is performed. This pass
is neither top-down or bottom-up, but in the execution order (with
additional complications for conditionals).  Optimizations performed
at this stage are subject to the same restrictions as in the pass 2.

在子例程（或者C<eval>或一个文件）的编译树构建完成后，会对代码进行一次额外的遍历。
这轮遍历既不是自顶向下，也不是自底向上，而是执行顺序（遇到条件判断的时候会比较复杂）。
这一阶段的优化和第二阶段的限制是一样的。

Peephole optimizations are done by calling the function pointed to
by the global variable C<PL_peepp>.  By default, C<PL_peepp> just
calls the function pointed to by the global variable C<PL_rpeepp>.
By default, that performs some basic op fixups and optimisations along
the execution-order op chain, and recursively calls C<PL_rpeepp> for
each side chain of ops (resulting from conditionals).  Extensions may
provide additional optimisations or fixups, hooking into either the
per-subroutine or recursive stage, like this:

窥孔优化通过调用全局变量C<PL_peepp>指向的函数进行。
默认情况下C<PL_peepp>只调用被全局变量C<PL_rpeepp>指向的函数。
默认情况下它只会做一下基本的op修正，对执行顺序上的op调用链进行优化，
并递归地对链条的每一边调用C<PL_rpeepp>（条件分支导致的）。
拓展可能会提供额外的优化或修正，在每个子例程或递归阶段中加入钩子，就像这样：

    static peep_t prev_peepp;
    static void my_peep(pTHX_ OP *o)
    {
        /* custom per-subroutine optimisation goes here */
        prev_peepp(aTHX_ o);
        /* custom per-subroutine optimisation may also go here */
    }
    BOOT:
        prev_peepp = PL_peepp;
        PL_peepp = my_peep;

    static peep_t prev_rpeepp;
    static void my_rpeep(pTHX_ OP *o)
    {
        OP *orig_o = o;
        for(; o; o = o->op_next) {
            /* custom per-op optimisation goes here */
        }
        prev_rpeepp(aTHX_ orig_o);
    }
    BOOT:
        prev_rpeepp = PL_rpeepp;
        PL_rpeepp = my_rpeep;

=head2 可拔插的runops

=head2 Pluggable runops

The compile tree is executed in a runops function.  There are two runops
functions, in F<run.c> and in F<dump.c>.  C<Perl_runops_debug> is used
with DEBUGGING and C<Perl_runops_standard> is used otherwise.  For fine
control over the execution of the compile tree it is possible to provide
your own runops function.

编译树在runops函数中执行。有两个runops函数，分别位于F<run.c>和F<dump.c>中。
C<Perl_runops_debug>被用于调试，而C<Perl_runops_standard>被用在其他地方。
为了更好地控制编译树的执行你可以提供你自己的runops函数。

It's probably best to copy one of the existing runops functions and
change it to suit your needs.  Then, in the BOOT section of your XS
file, add the line:

最好的方式是拷贝已存在的runops函数并修改以适应你的需求。然后在你的XS文件中的BOOT段加入一行：

  PL_runops = my_runops;

This function should be as efficient as possible to keep your programs
running as fast as possible.

该函数将尽可能高效地使你的程序尽可能快地运行。

=head2 编译期 域 钩子

=head2 Compile-time scope hooks

As of perl 5.14 it is possible to hook into the compile-time lexical
scope mechanism using C<Perl_blockhook_register>. This is used like
this:

自从5.14开始，可以使用C<Perl_blockhook_register>在编译期词法域加入钩子。
可以这样使用：

    STATIC void my_start_hook(pTHX_ int full);
    STATIC BHK my_hooks;

    BOOT:
        BhkENTRY_set(&my_hooks, bhk_start, my_start_hook);
        Perl_blockhook_register(aTHX_ &my_hooks);

This will arrange to have C<my_start_hook> called at the start of
compiling every lexical scope. The available hooks are:

着将导致每个此法域在编译开始的时候安置C<my start hook>。可以使用的钩子有：

=over 4

=item C<void bhk_start(pTHX_ int full)>

This is called just after starting a new lexical scope. Note that Perl
code like

这个将会在一个新的词法域开始的时候被调用。比如Perl代码：

    if ($x) { ... }

creates two scopes: the first starts at the C<(> and has C<full == 1>,
the second starts at the C<{> and has C<full == 0>. Both end at the
C<}>, so calls to C<start> and C<pre/post_end> will match. Anything
pushed onto the save stack by this hook will be popped just before the
scope ends (between the C<pre_> and C<post_end> hooks, in fact).

创建了两个域：第一个起始于C<(>并且有C<full == 1>，第二个起始于C<{>并且有C<full == 0>.
它们都终止于C<}>，因此调用的C<start>和C<pre/post_end>将匹配。
任何被钩子压到保存栈上的东西都会在退出域之前被弹出（事实上是在C<pre_>和C<post_end>钩子之间）。

=item C<void bhk_pre_end(pTHX_ OP **o)>

This is called at the end of a lexical scope, just before unwinding the
stack. I<o> is the root of the optree representing the scope; it is a
double pointer so you can replace the OP if you need to.

这个将会在堆栈回收之前，词法域的结尾被调用。
I<o>是optree的根，代表作用域；它是一个二级指针，所以如果需要的话你可以替换指向的OP。

=item C<void bhk_post_end(pTHX_ OP **o)>

This is called at the end of a lexical scope, just after unwinding the
stack. I<o> is as above. Note that it is possible for calls to C<pre_>
and C<post_end> to nest, if there is something on the save stack that
calls string eval.

这个将会在堆栈回收之前，词法域的结尾被调用。I<o>和之前的一样。注意C<pre_>和C<post_end>的嵌套调用是可能的，
如果在保存栈上调用字符串evel的话。

=item C<void bhk_eval(pTHX_ OP *const o)>

This is called just before starting to compile an C<eval STRING>, C<do
FILE>, C<require> or C<use>, after the eval has been set up. I<o> is the
OP that requested the eval, and will normally be an C<OP_ENTEREVAL>,
C<OP_DOFILE> or C<OP_REQUIRE>.

这个将在编译C<字符串eval>，C<do FILE>，C<require>或者C<use>之前调用，在eval被建立之后。
I<o>是请求eval的OP，一般都是C<OP_ENTEREVAL>，C<OP_DOFILE>或者C<OP_REQUIRE>.

=back

Once you have your hook functions, you need a C<BHK> structure to put
them in. It's best to allocate it statically, since there is no way to
free it once it's registered. The function pointers should be inserted
into this structure using the C<BhkENTRY_set> macro, which will also set
flags indicating which entries are valid. If you do need to allocate
your C<BHK> dynamically for some reason, be sure to zero it before you
start.

当你定义了自己的钩子函数，你需要一个C<BHK>结构体以将它们放置进去。最好能为它静态分配内存，
因为一旦注册就不可能回收了。通过C<BhkENTRY_set>宏将函数指针插入到结构中，它同时会设置相应字段表明插入的条目是合法的。
如果你实在需要为你的C<BHK>动态分配内存，能记得在开始之前将其清零。

Once registered, there is no mechanism to switch these hooks off, so if
that is necessary you will need to do this yourself. An entry in C<%^H>
is probably the best way, so the effect is lexically scoped; however it
is also possible to use the C<BhkDISABLE> and C<BhkENABLE> macros to
temporarily switch entries on and off. You should also be aware that
generally speaking at least one scope will have opened before your
extension is loaded, so you will see some C<pre/post_end> pairs that
didn't have a matching C<start>.

一旦注册就没有机制可以将这些钩子去掉了，因此如果需要的话你可以自己做这件事。
C<%^H>中的条目是最好的方式，这样的话效果就是词法域的；然而同样可以使用C<BhkDISABLE>和C<BhkENABLE>宏以暂时性的将条目开关。
你应该注意到一般来说在你的拓展被加载前止至少已经进入一个域了，所以你会发现一下C<pre/post_end>对没有匹配的C<start>。

=head1 使用C<dump>函数检查内部数据结构

=head1 Examining internal data structures with the C<dump> functions

To aid debugging, the source file F<dump.c> contains a number of
functions which produce formatted output of internal data structures.

为了帮助调试，F<dump.c>代码文件包含了一系列用于将内部数据结构格式化输出的函数。

The most commonly used of these functions is C<Perl_sv_dump>; it's used
for dumping SVs, AVs, HVs, and CVs. The C<Devel::Peek> module calls
C<sv_dump> to produce debugging output from Perl-space, so users of that
module should already be familiar with its format.

其中最通用的是C<Perl_sv_dump>；它被用于dump SVs, AVs, HVs, 和 CVs.
C<Devel::Peek>模块调用C<sv_dump>来生成Perl宏见的调试信息，所以这个模块的用于对格式已经很熟悉了。

C<Perl_op_dump> can be used to dump an C<OP> structure or any of its
derivatives, and produces output similar to C<perl -Dx>; in fact,
C<Perl_dump_eval> will dump the main root of the code being evaluated,
exactly like C<-Dx>.

C<Perl_op_dump>用于dump一个C<OP>或任何衍生的操作结构，并输出类似域C<perl -Dx>的内容；
事实上，C<Perl_dump_eval>将会dump执行代码的根，就向C<-Dx>一样。

Other useful functions are C<Perl_dump_sub>, which turns a C<GV> into an
op tree, C<Perl_dump_packsubs> which calls C<Perl_dump_sub> on all the
subroutines in a package like so: (Thankfully, these are all xsubs, so
there is no op tree)

其他有用的函数包括C<Perl_dump_sub>，它会将一个C<GV>转化为一个op树，
C<Perl_dump_packsubs>将对一个包中的所有子例程调用C<Perl_dump_sub>，就像这样（这些都是xsubs，所以没有op树）：

    (gdb) print Perl_dump_packsubs(PL_defstash)

    SUB attributes::bootstrap = (xsub 0x811fedc 0)

    SUB UNIVERSAL::can = (xsub 0x811f50c 0)

    SUB UNIVERSAL::isa = (xsub 0x811f304 0)

    SUB UNIVERSAL::VERSION = (xsub 0x811f7ac 0)

    SUB DynaLoader::boot_DynaLoader = (xsub 0x805b188 0)

and C<Perl_dump_all>, which dumps all the subroutines in the stash and
the op tree of the main root.

以及C<Perl_dump_all>用于stash中的所有子例程以及main根的op树dump出来。

=head1 如何做到多解释器和并发

=head1 How multiple interpreters and concurrency are supported

=head2 PERL_IMPLICIT_CONTEXT的背景

=head2 Background and PERL_IMPLICIT_CONTEXT

The Perl interpreter can be regarded as a closed box: it has an API
for feeding it code or otherwise making it do things, but it also has
functions for its own use.  This smells a lot like an object, and
there are ways for you to build Perl so that you can have multiple
interpreters, with one interpreter represented either as a C structure,
or inside a thread-specific structure.  These structures contain all
the context, the state of that interpreter.

Perl解释其可以被看作一种闭盒：它有一个输入代码的API或一些其他功能，
但是它也有自己使用的函数。这有点像一个对象，而且你可以将Perl编译为可以多解释器共存的模式，
一个解释器表示为一个C结构或者在专门一个线程的结构中。这些结构包含所有的上下文，解释器的状态。


One macro controls the major Perl build flavor: MULTIPLICITY. The
MULTIPLICITY build has a C structure that packages all the interpreter
state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also
normally defined, and enables the support for passing in a "hidden" first
argument that represents all three data structures. MULTIPLICITY makes
multi-threaded perls possible (with the ithreads threading model, related
to the macro USE_ITHREADS.)

有一个宏控制了主要的Perl编译方式：MULTIPLICITY。
MULTIPLICITY类型的编译有一个C结构打包了所有的解释器状态。
多解释器共存模式打开后，同样定义了PERL_IMPLICIT_CONTEXT，
并且支持通过第一个参数传递一个隐含对象，其包含了所有的三个数据结构。
MULTIPLICITY使perl可以支持多线程（使用ithreads线程模型，与USE_ITHREADS相关）。


Two other "encapsulation" macros are the PERL_GLOBAL_STRUCT and
PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the
former turns on MULTIPLICITY.)  The PERL_GLOBAL_STRUCT causes all the
internal variables of Perl to be wrapped inside a single global struct,
struct perl_vars, accessible as (globals) &PL_Vars or PL_VarsPtr or
the function  Perl_GetVars().  The PERL_GLOBAL_STRUCT_PRIVATE goes
one step further, there is still a single struct (allocated in main()
either from heap or from stack) but there are no global data symbols
pointing to it.  In either case the global struct should be initialised
as the very first thing in main() using Perl_init_global_struct() and
correspondingly tear it down after perl_free() using Perl_free_global_struct(),
please see F<miniperlmain.c> for usage details.  You may also need
to use C<dVAR> in your coding to "declare the global variables"
when you are using them.  dTHX does this for you automatically.

其他封装的宏包括PERL_GLOBAL_STRUCT 和 PERL_GLOBAL_STRUCT_PRIVATE
（后者打开前者，前者打开MULTIPLICIRY。）PERL_GLOBAL_STRUCT会将所有Perl内部的变量封装在一个全局结构中，
perl_vars，它可以通过（全局的）&PL_Vars或者VarsPtr或者函数Perl_GetVars()访问。
PERL_GLOBAL_STRUCT_PRIVATE则走的更远，
同样只分配了一个结构（在main()中分配，在堆上或者栈上）但是没有全局的数据符号指向它。
无论在哪种情况这个全局结构要在main()的最开头的地方使用Perl_init_global_struct()初始化并相应地在调用perl_free()后使用Perl_Free_global_struct()将其清理。
请参见F<miniperlmain.c>以获取使用细节。你也许需要在你的代码中使用C<dVAR>来“声明全局变量”。dTHX会自动为你这么做。

To see whether you have non-const data you can use a BSD-compatible C<nm>:

为了查看你是否有非常量的数据，可以使用C<nm>。

  nm libperl.a | grep -v ' [TURtr] '

If this displays any C<D> or C<d> symbols, you have non-const data.

如果它显示任何C<D>或C<d>符号，说明你有非常量数据。

For backward compatibility reasons defining just PERL_GLOBAL_STRUCT
doesn't actually hide all symbols inside a big global struct: some
PerlIO_xxx vtables are left visible.  The PERL_GLOBAL_STRUCT_PRIVATE
then hides everything (see how the PERLIO_FUNCS_DECL is used).

为了向前兼容，仅仅定义PERL_GLOBAL_STRUCT实际上并不会将这个全局结构体中的所有符号都隐藏起来：
一些PerlIO xxx 虚表依然可见。PERL_GLOBAL_STRUCT_PRIVATE会隐藏所有的东西（参考PERLOP_FUNC_DECL是怎么用的）。

All this obviously requires a way for the Perl internal functions to be
either subroutines taking some kind of structure as the first
argument, or subroutines taking nothing as the first argument.  To
enable these two very different ways of building the interpreter,
the Perl source (as it does in so many other situations) makes heavy
use of macros and subroutine naming conventions.

所有的这些显然需要Perl内部的函数要么可以对第一个参数做特殊处理要么不做特殊处理。
为了实现这两种完全不同的解释器构建方式，Perl代码（与其在其他很多场景的处理方式一样）大量使用了宏和子例程名称约定。

First problem: deciding which functions will be public API functions and
which will be private.  All functions whose names begin C<S_> are private
(think "S" for "secret" or "static").  All other functions begin with
"Perl_", but just because a function begins with "Perl_" does not mean it is
part of the API. (See L</Internal Functions>.) The easiest way to be B<sure> a
function is part of the API is to find its entry in L<perlapi>.
If it exists in L<perlapi>, it's part of the API.  If it doesn't, and you
think it should be (i.e., you need it for your extension), send mail via
L<perlbug> explaining why you think it should be.

第一个问题：函数如何判断是公共API还是私有的。所有以C<S_>开头的函数都是私有的。
其他函数都以"Perl_"开头，但是以"Perl"开头并不意味着这个函数是API的一部分。（参见L<内部函数>。）
查看一个函数是否为API最简单的方法就是参考L<perlapi>文档。如果在文档中，就是API。如果不在而你又认为它应该是（比如你在你的拓展中用到）。
请通过L<perlbug>发邮件以解释你的理由。

Second problem: there must be a syntax so that the same subroutine
declarations and calls can pass a structure as their first argument,
or pass nothing.  To solve this, the subroutines are named and
declared in a particular way.  Here's a typical start of a static
function used within the Perl guts:

第二个问题：必须要有一种语法使得同样的子例程声明可以支持将一个结构体通过第一个参数传入或者什么都不传。
为了解决这个问题，子例程用一种特殊的方式命名和声明。这是Perl guts使用的静态函数的典型开始：

  STATIC void
  S_incline(pTHX_ char *s)

STATIC becomes "static" in C, and may be #define'd to nothing in some
configurations in the future.

STATIC就是C中的"static"，但也可能在将来被定义为空。

A public function (i.e. part of the internal API, but not necessarily
sanctioned for use in extensions) begins like this:

一个公共函数（比如内部API的一部分，但是被限制用于拓展）可以这样开始：

  void
  Perl_sv_setiv(pTHX_ SV* dsv, IV num)

C<pTHX_> is one of a number of macros (in F<perl.h>) that hide the
details of the interpreter's context.  THX stands for "thread", "this",
or "thingy", as the case may be.  (And no, George Lucas is not involved. :-)
The first character could be 'p' for a B<p>rototype, 'a' for B<a>rgument,
or 'd' for B<d>eclaration, so we have C<pTHX>, C<aTHX> and C<dTHX>, and
their variants.

C<pTHX_>是F<perl.h>中定义的宏，它隐藏了解释其上下文的细节。THX代表"thread"，"this"或"thingy"，
根据场景的不同而不同。第一个字符可以是'p'表示原型，'a'表示参数，d表示声明。
所以我们有C<pTHX>, C<aTHX> 和 C<dTHX>以及它们的变种。

When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no
first argument containing the interpreter's context.  The trailing underscore
in the pTHX_ macro indicates that the macro expansion needs a comma
after the context argument because other arguments follow it.  If
PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the
subroutine is not prototyped to take the extra argument.  The form of the
macro without the trailing underscore is used when there are no additional
explicit arguments.

当Perl编译的时候没有设置PERL_IMPLICIT_CONTEXT，那么就没有包含解释器上下文的参数了。
pTHX_宏尾部的下划线表示宏拓展需要在上下文参数后面加一个逗号，因为还有其他参数在它后面。
如果没有定义PERL_IMPLICIT_CONTEXT，pTHX_将被忽略，子例程就不会被原型化以处理多余的参数。
当不需要额外的参数时使用没有下划线的宏。

When a core function calls another, it must pass the context.  This
is normally hidden via macros.  Consider C<sv_setiv>.  It expands into
something like this:

当一个核心函数调用另一个的时候，它必须传递上下文。这通常被隐藏在宏中。例如C<sv_setiv>会被拓展为：

    #ifdef PERL_IMPLICIT_CONTEXT
      #define sv_setiv(a,b)      Perl_sv_setiv(aTHX_ a, b)
      /* can't do this for vararg functions, see below */
    #else
      #define sv_setiv           Perl_sv_setiv
    #endif

This works well, and means that XS authors can gleefully write:

这样工作得很好，同样意味着XS作者可以这样写：

    sv_setiv(foo, bar);

and still have it work under all the modes Perl could have been
compiled with.

而且可以在任何方式构建的Perl中工作。

This doesn't work so cleanly for varargs functions, though, as macros
imply that the number of arguments is known in advance.  Instead we
either need to spell them out fully, passing C<aTHX_> as the first
argument (the Perl core tends to do this with functions like
Perl_warner), or use a context-free version.

对于varargs函数来说这样并不是很清晰，尽管宏指定了已知参数的数量。
因此我们要么需要将它们完整地表示出来，C<aTHX_>作为第一个参数传入
（Perl内部在Perl_warner这样的函数中就是如此使用的），要么使用上下文无关的版本。

The context-free version of Perl_warner is called
Perl_warner_nocontext, and does not take the extra argument.  Instead
it does dTHX; to get the context from thread-local storage.  We
C<#define warner Perl_warner_nocontext> so that extensions get source
compatibility at the expense of performance.  (Passing an arg is
cheaper than grabbing it from thread-local storage.)

上下文无关版本的Perl_warner称作Perl_Warner_nocontext，而且不携带而外参数。
取而代之的是使用dTHX；以从线程本地储存空间中获取上下文。
我们C<#define warner Perl_warner_nocontext>，这样拓展就可以以执行效率为代价保持一致性了。
（传入一个参数要比从线程存储空间中获取更高效。）

You can ignore [pad]THXx when browsing the Perl headers/sources.
Those are strictly for use within the core.  Extensions and embedders
need only be aware of [pad]THX.

当你查看Perl 头文件或代码时可以忽略[pad]THXx。它们都是内部使用的。
拓展和内嵌的代码只需要关注[pad]THX。

=head2 dTHR发生了什么？

=head2 So what happened to dTHR?

C<dTHR> was introduced in perl 5.005 to support the older thread model.
The older thread model now uses the C<THX> mechanism to pass context
pointers around, so C<dTHR> is not useful any more.  Perl 5.6.0 and
later still have it for backward source compatibility, but it is defined
to be a no-op.

C<dTHR>是5.005引入的以支持更早的线程模型。更早的线程模型使用C<THX>机制传递上下文指针，
所以C<dTHR>现在不再使用了。Perl 5.6.0以及之后仍然有这个是为了爆出代码上向前适配，但是它被定义为一个no_op。

=head2 在拓展中我如何使用这些？

=head2 How do I use all this in extensions?

When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call
any functions in the Perl API will need to pass the initial context
argument somehow.  The kicker is that you will need to write it in
such a way that the extension still compiles when Perl hasn't been
built with PERL_IMPLICIT_CONTEXT enabled.

当Perl构建的时候打开了PERL_IMPLICIT_CONTEXT，拓展调用任何Perl API的时候需要用某种方式传递初始化的上下文。
问题在于你的写法要能保证拓展在没有打开PERL_IMPLICIT_CONTEXT构建的Perl版本中依然能够正确编译。

There are three ways to do this.  First, the easy but inefficient way,
which is also the default, in order to maintain source compatibility
with extensions: whenever F<XSUB.h> is #included, it redefines the aTHX
and aTHX_ macros to call a function that will return the context.
Thus, something like:

有三种方式可以这样做。首先，最简单但是最低效的方式（默认）是：
当F<XSUB.h>被#include的时候，将会重定义aTHX和aTHX_宏以调用一个返回上下文的函数。
因此，像这样的写法：

        sv_setiv(sv, num);

in your extension will translate to this when PERL_IMPLICIT_CONTEXT is
in effect:

当打PERL_IMPLICIT_CONTEXT的时候，在你的拓展中将被翻译为：

        Perl_sv_setiv(Perl_get_context(), sv, num);

or to this otherwise:

否则是：

        Perl_sv_setiv(sv, num);

You don't have to do anything new in your extension to get this; since
the Perl library provides Perl_get_context(), it will all just
work.

你不许要做任何事情就可以获得这种效果；因为Perl库提供了Perl_get_context()，它已经可以工作了。

The second, more efficient way is to use the following template for
your Foo.xs:

第二个方式更加有效：就是在你的Foo.xs文件中使用以下模板：

        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
        #include "EXTERN.h"
        #include "perl.h"
        #include "XSUB.h"

        STATIC void my_private_function(int arg1, int arg2);

        STATIC void
        my_private_function(int arg1, int arg2)
        {
            dTHX;       /* fetch context */
            ... call many Perl API functions ...
        }

        [... etc ...]

        MODULE = Foo            PACKAGE = Foo

        /* typical XSUB */

        void
        my_xsub(arg)
                int arg
            CODE:
                my_private_function(arg, 10);

Note that the only two changes from the normal way of writing an
extension is the addition of a C<#define PERL_NO_GET_CONTEXT> before
including the Perl headers, followed by a C<dTHX;> declaration at
the start of every function that will call the Perl API.  (You'll
know which functions need this, because the C compiler will complain
that there's an undeclared identifier in those functions.)  No changes
are needed for the XSUBs themselves, because the XS() macro is
correctly defined to pass in the implicit context if needed.

注意唯一两个和普通写法不同的就是在包含Perl头文件之前添加了C<#define PERL_NO_GET_CONTEXT>，
并且在每一个会调用Perl API的函数的开始处声明C<dTHX;>。
（你会知道哪些函数需要这个，因为C编译器将会提示这些函数中有未声明的标识符。）
XSUBs不许要任何改变，因为XS()宏被正确地定义在需要的时候传递上下文。

The third, even more efficient way is to ape how it is done within
the Perl guts:

第三种方式通过模仿Perl guts中的做法，更为高效：


        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
        #include "EXTERN.h"
        #include "perl.h"
        #include "XSUB.h"

        /* pTHX_ only needed for functions that call Perl API */
        STATIC void my_private_function(pTHX_ int arg1, int arg2);

        STATIC void
        my_private_function(pTHX_ int arg1, int arg2)
        {
            /* dTHX; not needed here, because THX is an argument */
            ... call Perl API functions ...
        }

        [... etc ...]

        MODULE = Foo            PACKAGE = Foo

        /* typical XSUB */

        void
        my_xsub(arg)
                int arg
            CODE:
                my_private_function(aTHX_ arg, 10);

This implementation never has to fetch the context using a function
call, since it is always passed as an extra argument.  Depending on
your needs for simplicity or efficiency, you may mix the previous
two approaches freely.

这种实现不许要通过函数主动获取上下文，因为它总是通过一个额外参数传进来。
基于你追求的是效率还是实现上的简单，你可以任意混合以上两种用法。

Never add a comma after C<pTHX> yourself--always use the form of the
macro with the underscore for functions that take explicit arguments,
or the form without the argument for functions with no explicit arguments.

永远不要在C<pTHX>后面加逗号，记住在需要额外参数的函数上需要使用加下划线的宏，
对于没有参数的函数用没有下划线的形式。

If one is compiling Perl with the C<-DPERL_GLOBAL_STRUCT> the C<dVAR>
definition is needed if the Perl global variables (see F<perlvars.h>
or F<globvar.sym>) are accessed in the function and C<dTHX> is not
used (the C<dTHX> includes the C<dVAR> if necessary).  One notices
the need for C<dVAR> only with the said compile-time define, because
otherwise the Perl global variables are visible as-is.

当Perl编译时打开了C<-DPERL_GLOBAL_STRUCT>，
如果你的函数需要访问Perl全局变量（参见F<perlvars.h>或者F<globvar.sym>）
且没有使用C<dTHX>的时候（C<dTHX>会在必要的时候包含C<dVAR>）就需要C<dVAR>定义了。
注意只有在所谓的编译器定义才需要C<dVAR>，因为否则的话Perl全局变量已经是可见的了。

=head2 当在多线程中调用perl的时候需要注意什么？

=head2 Should I do anything special if I call perl from multiple threads?

If you create interpreters in one thread and then proceed to call them in
another, you need to make sure perl's own Thread Local Storage (TLS) slot is
initialized correctly in each of those threads.

如果你在一个线程中创建了解释其并在另一个线程中调用，你需要保证perl自己的线程本地存储（TLS）在每一个线程都被正确初始化了。

The C<perl_alloc> and C<perl_clone> API functions will automatically set
the TLS slot to the interpreter they created, so that there is no need to do
anything special if the interpreter is always accessed in the same thread that
created it, and that thread did not create or call any other interpreters
afterwards.  If that is not the case, you have to set the TLS slot of the
thread before calling any functions in the Perl API on that particular
interpreter.  This is done by calling the C<PERL_SET_CONTEXT> macro in that
thread as the first thing you do:

C<perl_alloc> 和 C<perl_clone> API函数都会在它们创建的解释器上自动设置TLS，
因此如果解释器都是通过创建它的线程访问且该线程不会创建或调用其他解释器2的话是不许要做任何操作的。
如果不是这样，以需要在某个解释器上调用任何Perl API之前都需要设置当前线程的TLS。
也就是说在那个线程中首先要做的是调用C<PERL_SET_CONTEXT>宏：

	/* do this before doing anything else with some_perl */
	PERL_SET_CONTEXT(some_perl);

	... other Perl API calls on some_perl go here ...

=head2 未来的计划以及PERL_IMPLICIT_SYS

=head2 Future Plans and PERL_IMPLICIT_SYS

Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up everything
that the interpreter knows about itself and pass it around, so too are
there plans to allow the interpreter to bundle up everything it knows
about the environment it's running on.  This is enabled with the
PERL_IMPLICIT_SYS macro.  Currently it only works with USE_ITHREADS on
Windows.

正如PERL_IMPLICIT_CONTEXT为解释器提供了打包所有当前解释器所知的关于自身的信息并将其传递的能力，
同样有使得解释器可以打包任何它知道关于运行环境的信息的计划。这个能力是通过打开PERL_IMPLICIT_SYS宏实现的。
目前它值在USE_ITHREADS的Windows系统版本上可用。

This allows the ability to provide an extra pointer (called the "host"
environment) for all the system calls.  This makes it possible for
all the system stuff to maintain their own state, broken down into
seven C structures.  These are thin wrappers around the usual system
calls (see F<win32/perllib.c>) for the default perl executable, but for a
more ambitious host (like the one that would do fork() emulation) all
the extra work needed to pretend that different interpreters are
actually different "processes", would be done here.

它能够为所有的系统调用提供额外的指针（称作"宿主"环境）。这使得所有的系统可以维护其自身的状态，
将其分解到七个C结构中。对于默认的perl执行程序它们都是通用系统调用(参考 F<win32/perllib.c>)的简单封装，
但是对于更加有野心的宿主（例如会做fork()模拟的那种）那些为了假装不同的解释器实际上是不同的“进程”的额外工作都要在这里做。

The Perl engine/interpreter and the host are orthogonal entities.
There could be one or more interpreters in a process, and one or
more "hosts", with free association between them.

Perl 引擎/解释器与宿主都是正交的。一个进程中可以有多个解释器，多个"宿主"，它们之间的关系都是自由的。

=head1 内部函数

=head1 Internal Functions

All of Perl's internal functions which will be exposed to the outside
world are prefixed by C<Perl_> so that they will not conflict with XS
functions or functions used in a program in which Perl is embedded.
Similarly, all global variables begin with C<PL_>. (By convention,
static functions start with C<S_>.)

所有暴露到外界的Perl内部函数都以C<Perl_>开头，因此它们不会和XS函数或嵌入Perl的宿主程序中的函数冲突。
相似的，所有的全局变量都以C<PL_>开头。（按照约定，静态函数以C<S_>开头。）

Inside the Perl core (C<PERL_CORE> defined), you can get at the functions
either with or without the C<Perl_> prefix, thanks to a bunch of defines
that live in F<embed.h>. Note that extension code should I<not> set
C<PERL_CORE>; this exposes the full perl internals, and is likely to cause
breakage of the XS in each new perl release.

在Perl的核心中（C<定义了PERL_CORE>），因为F<embed.h>中的一系列定义，
你可以不加C<Perl_>前缀以获取这些函数。注意拓展的代码不应该设置C<PERL_CORE>；
这样会将perl内部暴露在外，可能会导致新版本中XS的损坏。

The file F<embed.h> is generated automatically from
F<embed.pl> and F<embed.fnc>. F<embed.pl> also creates the prototyping
header files for the internal functions, generates the documentation
and a lot of other bits and pieces. It's important that when you add
a new function to the core or change an existing one, you change the
data in the table in F<embed.fnc> as well. Here's a sample entry from
that table:

F<embed.h>文件是通过F<embed.pl>和F<embed.fnc>自动生成的。
F<embed.pl>同时为内部函数创建了原型头文件，生成文档以及其他一些东西。
它非常重要，当你在内核添加一个新的函数或修改已有函数时你要同时修改F<embed.fnc>中表里的数据。
这是表中一组数据的例子：

    Apd |SV**   |av_fetch   |AV* ar|I32 key|I32 lval

The second column is the return type, the third column the name. Columns
after that are the arguments. The first column is a set of flags:

第二列是返回类型，第三列是名称，剩下的是参数。第一列是一系列标记：

=over 3

=item A

This function is a part of the public API. All such functions should also
have 'd', very few do not.

这个函数是公共API的部分。所有这样的函数都同样有'd'标记，极少数没有。

=item p

This function has a C<Perl_> prefix; i.e. it is defined as
C<Perl_av_fetch>.

这个函数有C<Perl_>前缀。它被定义为C<Perl_av_fetch>

=item d

This function has documentation using the C<apidoc> feature which we'll
look at in a second.  Some functions have 'd' but not 'A'; docs are good.

这个函数通过C<apidoc>特性而拥有文档，在后面还会再此提到它。一些函数有'd'但是没有'A'；文档是好的。

=back

Other available flags are:

其他可获得的标记有：

=over 3

=item s

This is a static function and is defined as C<STATIC S_whatever>, and
usually called within the sources as C<whatever(...)>.

这是一个被定义为C<STATIC_S_whatever>静态函数并且通常在源码中以C<wharever(...)>的方式被调用。

=item n

This does not need an interpreter context, so the definition has no
C<pTHX>, and it follows that callers don't use C<aTHX>.  (See
L</Background and PERL_IMPLICIT_CONTEXT>.)

这个函数不许要解释器上下文，因此定义没有C<pTHX>，它同样意味着调用者不使用C<aTHX>。
（查看L<PERL_IMPLICIT_CONTEXT的背景>。）

=item r

This function never returns; C<croak>, C<exit> and friends.

这个函数永远不会返回；C<croak>，C<exit>和类似的一些函数。

=item f

This function takes a variable number of arguments, C<printf> style.
The argument list should end with C<...>, like this:

这个函数有变长参数，类似于C<printf>的风格。
参数列表因该以C<...>结尾，就像这样：

    Afprd   |void   |croak          |const char* pat|...

=item M

This function is part of the experimental development API, and may change
or disappear without notice.

这个函数是实验性的API，可能不加通知地改变或删除。

=item o

This function should not have a compatibility macro to define, say,
C<Perl_parse> to C<parse>. It must be called as C<Perl_parse>.

这个函数有一个对应的宏定义，例如C<Perl_parse>与C<parse>。它必须以C<Perl_parse>的方式调用。

=item x

This function isn't exported out of the Perl core.

这个函数不会被导出到Perl核心之外。

=item m

This is implemented as a macro.

这个以宏的形式实现。

=item X

This function is explicitly exported.

这个函数被显式导出。

=item E

This function is visible to extensions included in the Perl core.

这个函数对于Perl核心拓展而言可见。

=item b

Binary backward compatibility; this function is a macro but also has
a C<Perl_> implementation (which is exported).

二进制适配；这个函数是一个宏但是同样有一个C<Perl_>的实现（被导出的）。

=item others

See the comments at the top of C<embed.fnc> for others.

请参看C<embed.fnc>顶部的注释以获取其他信息。

=back

If you edit F<embed.pl> or F<embed.fnc>, you will need to run
C<make regen_headers> to force a rebuild of F<embed.h> and other
auto-generated files.

如果你编辑了F<embed.pl>或F<embed.fnc>，你将需要运行C<make_regen_headers>来强制重新构建F<embed.h>和其他自动生成的文件。

=head2 格式化打印IVs，UVs和NVs。

=head2 Formatted Printing of IVs, UVs, and NVs

If you are printing IVs, UVs, or NVS instead of the stdio(3) style
formatting codes like C<%d>, C<%ld>, C<%f>, you should use the
following macros for portability

如果你需要打印IVs，UVs或者NVs而且不用stdio(3)的风格格式化码（比如C<%d>, C<%ld>, C<%f>），为了可移植性你应该使用以下宏：

        IVdf            IV in decimal
        UVuf            UV in decimal
        UVof            UV in octal
        UVxf            UV in hexadecimal
        NVef            NV %e-like
        NVff            NV %f-like
        NVgf            NV %g-like

These will take care of 64-bit integers and long doubles.
For example:

它们会处理64位的整型和long double型。例如：

        printf("IV is %"IVdf"\n", iv);

The IVdf will expand to whatever is the correct format for the IVs.

IVdf将会拓展为对于IVs来说始终正确的样式。

If you are printing addresses of pointers, use UVxf combined
with PTR2UV(), do not use %lx or %p.

如果你需要打印指针地址，使用UVxf联合PTR2UV()，而不要使用%lx或着%p。

=head2 指针转整型和整型转指针

=head2 Pointer-To-Integer and Integer-To-Pointer

Because pointer size does not necessarily equal integer size,
use the follow macros to do it right.

因为指针的大小不一定等于整型大小，使用以下宏来做正确的转换。

        PTR2UV(pointer)
        PTR2IV(pointer)
        PTR2NV(pointer)
        INT2PTR(pointertotype, integer)

For example:

例如：

        IV  iv = ...;
        SV *sv = INT2PTR(SV*, iv);

and

        AV *av = ...;
        UV  uv = PTR2UV(av);

=head2 异常处理

=head2 Exception Handling

There are a couple of macros to do very basic exception handling in XS
modules. You have to define C<NO_XSLOCKS> before including F<XSUB.h> to
be able to use these macros:

有一系列宏用于在XS模块中进行基本的异常处理。你需要在包含F<XSUB.h>之前定义C<NO_XSLOCKS>以使用这些宏：

        #define NO_XSLOCKS
        #include "XSUB.h"

You can use these macros if you call code that may croak, but you need
to do some cleanup before giving control back to Perl. For example:

在调用一些可能失败的代码时你可以使用这些宏，但是你需要在将控制交回给Perl之前做一些清理工作。例如：

        dXCPT;    /* set up necessary variables */

        XCPT_TRY_START {
          code_that_may_croak();
        } XCPT_TRY_END

        XCPT_CATCH
        {
          /* do cleanup here */
          XCPT_RETHROW;
        }

Note that you always have to rethrow an exception that has been
caught. Using these macros, it is not possible to just catch the
exception and ignore it. If you have to ignore the exception, you
have to use the C<call_*> function.

注意你总是要再一次抛出被捕获的异常。使用这些宏不可能只捕获异常然后就忽略。如果你必须要忽略异常的话，你必须使用C<call *>系列函数。

The advantage of using the above macros is that you don't have
to setup an extra function for C<call_*>, and that using these
macros is faster than using C<call_*>.

使用以上宏的好处在于你不许要为C<call *>建立额外的函数，并且用这些宏要比直接使用C<call*>更快。

=head2 源文件文档

=head2 Source Documentation

There's an effort going on to document the internal functions and
automatically produce reference manuals from them - L<perlapi> is one
such manual which details all the functions which are available to XS
writers. L<perlintern> is the autogenerated manual for the functions
which are not part of the API and are supposedly for internal use only.

我们正努力为内部函数添加文档并根据它们自动生成索引手册- L<perlapi>是其中一部描述所有XS作者可用函数的手册。
L<perlintern>是根据那些不属于API，只支持内部使用的函数自动生成的手册。

Source documentation is created by putting POD comments into the C
source, like this:

源文件文档是通过向C源码中添加POD注释实现的，例如这样：

 /*
 =for apidoc sv_setiv

 Copies an integer into the given SV.  Does not handle 'set' magic.  See
 C<sv_setiv_mg>.

 =cut
 */

Please try and supply some documentation if you add functions to the
Perl core.

如果你要向Perl核心添加函数的话请尝试提供一些文档。

=head2 向后兼容

=head2 Backwards compatibility

The Perl API changes over time. New functions are added or the interfaces
of existing functions are changed. The C<Devel::PPPort> module tries to
provide compatibility code for some of these changes, so XS writers don't
have to code it themselves when supporting multiple versions of Perl.

Perl API是不断变化的。新的函数不断添加，已有函数不断改变。C<Devel::PPPort>模块试图为这些变化提供适配代码，
因此XS作者不用自己去写这些代码就可以支持多版本的Perl了。

C<Devel::PPPort> generates a C header file F<ppport.h> that can also
be run as a Perl script. To generate F<ppport.h>, run:

C<Devel::PPPort>同样以运行一个脚本的形式生成一个C头文件F<ppport.h>。
运行：

    perl -MDevel::PPPort -eDevel::PPPort::WriteFile

Besides checking existing XS code, the script can also be used to retrieve
compatibility information for various API calls using the C<--api-info>
command line switch. For example:

除了检查已存在的XS代码外，这个脚本同样可以通过C<--api-info>选项追溯各个版本API调用的适配信息。
例如这样：

  % perl ppport.h --api-info=sv_magicext

For details, see C<perldoc ppport.h>.

参见C<perldoc ppport.h>以获取更多细节。

=head1 Unicode 支持

=head1 Unicode Support

Perl 5.6.0 introduced Unicode support. It's important for porters and XS
writers to understand this support and make sure that the code they
write does not corrupt Unicode data.

Perl 5.6.0 引入Unicode支持。理解这种支持以确保不会写出导致Unicode数据损坏的代码对于porters和XS作者非常重要。

=head2 那么什么是Unicode？

=head2 What B<is> Unicode, anyway?

In the olden, less enlightened times, we all used to use ASCII. Most of
us did, anyway. The big problem with ASCII is that it's American. Well,
no, that's not actually the problem; the problem is that it's not
particularly useful for people who don't use the Roman alphabet. What
used to happen was that particular languages would stick their own
alphabet in the upper range of the sequence, between 128 and 255. Of
course, we then ended up with plenty of variants that weren't quite
ASCII, and the whole point of it being a standard was lost.

很久很久以前我们大部分使用的都是ASCII码。ASCII最大的问题在于它是专门为美国设置的。
当然着并非实际的问题；问题在于对不使用罗马字母表的人来说ASCII不是非常有用。
其他语言的用户曾经将序列的上半部分，128到255之间，用于他们自己的字母表。
当然这样导致了各种不属于ASCII的变种，标准的意义就没有了。

Worse still, if you've got a language like Chinese or
Japanese that has hundreds or thousands of characters, then you really
can't fit them into a mere 256, so they had to forget about ASCII
altogether, and build their own systems using pairs of numbers to refer
to one character.


更加糟糕的是如果你使用的是有成百上千字符的汉语或日语，那就无法用256个字符表示了，
因此只能完全放弃ASCII而使用数字组合建立他们自己的系统。

To fix this, some people formed Unicode, Inc. and
produced a new character set containing all the characters you can
possibly think of and more. There are several ways of representing these
characters, and the one Perl uses is called UTF-8. UTF-8 uses
a variable number of bytes to represent a character. You can learn more
about Unicode and Perl's Unicode model in L<perlunicode>.

为了解决这个问题，一些人创建了Unicode标准。制定了一个包含所有你能想象到的字符的字母集。
表示这些字符的方式有很多中，Perl使用的方式称作UTF-8。UTF-8使用变长数量的字节代表字符。
你可以参看L<perlunicode>以获取关于Unicode和Perl Unicode模型的更多信息。

=head2 我怎样识别UTF-8字符串？

=head2 How can I recognise a UTF-8 string?

You can't. This is because UTF-8 data is stored in bytes just like
non-UTF-8 data. The Unicode character 200, (C<0xC8> for you hex types)
capital E with a grave accent, is represented by the two bytes
C<v196.172>. Unfortunately, the non-Unicode string C<chr(196).chr(172)>
has that byte sequence as well. So you can't tell just by looking - this
is what makes Unicode input an interesting problem.

你无法识别。因为UTF-8数据与其他数据一样是存在字节中的。Unicode字符200，
（16进制的C<0xC8>）抑音的大写E，是通过两个字节C<v196.172>表示的。
不幸的是，非Unicode字符串C<chr(196).chr(172)>的字节序列与之相同。
所以你无法识别出你看到的是什么-这使得如何判断什么是Unicode输入成为一个有趣的问题。

In general, you either have to know what you're dealing with, or you
have to guess.  The API function C<is_utf8_string> can help; it'll tell
you if a string contains only valid UTF-8 characters. However, it can't
do the work for you. On a character-by-character basis,
C<is_utf8_char_buf>
will tell you whether the current character in a string is valid UTF-8. 

一般而言，要们你必须知道你在处理的数据是什么，要么你得猜出来。
C<is_utf8_string>API函数可以帮助你；它会告诉你一个字符串是否只包含合法的UTF-8字符。
但是它不能帮你完成你的工作。对于字符逐个判断，C<is_utf8_char_bug>将会告诉你字符串的当前字符是否为合法的UTF-8。

=head2 UTF-8如何表示Unicode字符？

=head2 How does UTF-8 represent Unicode characters?

As mentioned above, UTF-8 uses a variable number of bytes to store a
character. Characters with values 0...127 are stored in one byte, just
like good ol' ASCII. Character 128 is stored as C<v194.128>; this
continues up to character 191, which is C<v194.191>. Now we've run out of
bits (191 is binary C<10111111>) so we move on; 192 is C<v195.128>. And
so it goes on, moving to three bytes at character 2048.

如上文所提到的那样，UTF-8使用变长数量的字节存储一个字符。
字符值在0...127之间的存坐在一个字节中，就和ASCII标准中的一样。字符128保存为C<v194.128>；
这样持续到字符191，也就是C<v194.191>。此时我们既要越界了（191二进制为C<10111111>），所以继续；
192是C<v195.128>。然后接着来，直到字符2048开始使用三个字节。

Assuming you know you're dealing with a UTF-8 string, you can find out
how long the first character in it is with the C<UTF8SKIP> macro:

假设你知道你正在处理UTF-8字符串，你可以通过C<UTF8SKIP>得到第一个字符的长度：

    char *utf = "\305\233\340\240\201";
    I32 len;

    len = UTF8SKIP(utf); /* len is 2 here */
    utf += len;
    len = UTF8SKIP(utf); /* len is 3 here */

Another way to skip over characters in a UTF-8 string is to use
C<utf8_hop>, which takes a string and a number of characters to skip
over. You're on your own about bounds checking, though, so don't use it
lightly.

第二种在UTF-8字符串中跳过字符的方式是使用C<utf8_hop>，它传入一个字符串和一个需要跳过字符的数量。
你需要字节解决边界检查问题，所以不要随便使用这个函数。

All bytes in a multi-byte UTF-8 character will have the high bit set,
so you can test if you need to do something special with this
character like this (the UTF8_IS_INVARIANT() is a macro that tests
whether the byte can be encoded as a single byte even in UTF-8):

一个多字节的UTF-8字符中的所有字节的高位比特都被置位了，
所以你可以这样测试你是否需要对这个字符做特殊处理（UTF8_IS_INVARINT()是一个测试这个字节是否可以被编码为单字节，即使是在UTF-8中）：

    U8 *utf;
    U8 *utf_end; /* 1 beyond buffer pointed to by utf */
    UV uv;	/* Note: a UV, not a U8, not a char */
    STRLEN len; /* length of character in bytes */

    if (!UTF8_IS_INVARIANT(*utf))
        /* Must treat this as UTF-8 */
        uv = utf8_to_uvchr_buf(utf, utf_end, &len);
    else
        /* OK to treat this character as a byte */
        uv = *utf;

You can also see in that example that we use C<utf8_to_uvchr_buf> to get the
value of the character; the inverse function C<uvchr_to_utf8> is available
for putting a UV into UTF-8:

你同样可以看到在这个例子中我们使用C<utf8_to_uvchr_buf>获得字符的值；
反向的函数C<uvchr_to_utf8>被用于将一个UV转为UTF-8：

    if (!UTF8_IS_INVARIANT(uv))
        /* Must treat this as UTF8 */
        utf8 = uvchr_to_utf8(utf8, uv);
    else
        /* OK to treat this character as a byte */
        *utf8++ = uv;

You B<must> convert characters to UVs using the above functions if
you're ever in a situation where you have to match UTF-8 and non-UTF-8
characters. You may not skip over UTF-8 characters in this case. If you
do this, you'll lose the ability to match hi-bit non-UTF-8 characters;
for instance, if your UTF-8 string contains C<v196.172>, and you skip
that character, you can never match a C<chr(200)> in a non-UTF-8 string.
So don't do that!

当你需要匹配UTF-8与非UTF-8字符的时候必须要使用上列函数将字符转为UV。
在该场景下你也许不需要跳过UTF-8字符。如果你这样做，你将会时区匹配非UTF-8字符串中高位字符的能力；
例如：如果你的UTF-8字符串中包含C<v196.172>，你跳过这个字符，
你永远都无法在一个非UTF-8字符串中匹配一个C<chr(200)>字符。
因此不要那样做！

=head2 Perl如何存储UTF-8字符串

=head2 How does Perl store UTF-8 strings?

Currently, Perl deals with Unicode strings and non-Unicode strings
slightly differently. A flag in the SV, C<SVf_UTF8>, indicates that the
string is internally encoded as UTF-8. Without it, the byte value is the
codepoint number and vice versa (in other words, the string is encoded
as iso-8859-1, but C<use feature 'unicode_strings'> is needed to get iso-8859-1
semantics). You can check and manipulate this flag with the
following macros:

当前Perl在处理Unicode字符串和非Unicode字符串时稍微有些不同。
SV中的一个标记C<SVf_UTF8>用于标识字符串是内部编码为UTF-8的。
没有它，字节值就是编码数字，反之亦然（另一方面，如果字符串被编码为iso-8859-1，你需要C<use feature 'unicode_strings'>以获得iso-8859-1的语义）。
你可以使用以下宏检查和修改这个标志。

    SvUTF8(sv)
    SvUTF8_on(sv)
    SvUTF8_off(sv)

This flag has an important effect on Perl's treatment of the string: if
Unicode data is not properly distinguished, regular expressions,
C<length>, C<substr> and other string handling operations will have
undesirable results.

这个标记对于Perl对待字符串的方式有很大的影响：如果Unicode数据没有被识别，
正则表达式，C<length>, C<substr>和其他一些字符串处理操作都会有无法预料的结果。

The problem comes when you have, for instance, a string that isn't
flagged as UTF-8, and contains a byte sequence that could be UTF-8 -
especially when combining non-UTF-8 and UTF-8 strings.

问题源于当你有一个没有标识为UTF-8的字符串，它包含了UTF-8或部分UTF-8的字节的时候。

Never forget that the C<SVf_UTF8> flag is separate to the PV value; you
need be sure you don't accidentally knock it off while you're
manipulating SVs. More specifically, you cannot expect to do this:

永远不要忘记C<SVf_UTF8>标记和PV值是分开的；当处理SV的时候你要保证不会不小心将它漏掉。
尤其是，你不应该这样做：

    SV *sv;
    SV *nsv;
    STRLEN len;
    char *p;

    p = SvPV(sv, len);
    frobnicate(p);
    nsv = newSVpvn(p, len);

The C<char*> string does not tell you the whole story, and you can't
copy or reconstruct an SV just by copying the string value. Check if the
old SV has the UTF8 flag set, and act accordingly:

C<char*>字符串不会告诉你所有的东西，你不可以仅仅只通过拷贝其中的字符串来重新构造SV。
检查之前的SV是否将UTF8标志置位，据此进行操作：

    p = SvPV(sv, len);
    frobnicate(p);
    nsv = newSVpvn(p, len);
    if (SvUTF8(sv))
        SvUTF8_on(nsv);

In fact, your C<frobnicate> function should be made aware of whether or
not it's dealing with UTF-8 data, so that it can handle the string
appropriately.

事实上，你的C<frobnicate>函数应该需要知道它是否在处理UTF-8编码的数据，这样它才能正确处理字符串。

Since just passing an SV to an XS function and copying the data of
the SV is not enough to copy the UTF8 flags, even less right is just
passing a C<char *> to an XS function.

由于向一个XS函数传递SV并拷贝SV的数据并不足以拷贝UTF8标记，如果仅仅传一个C<char *>就更加不正确了。

=head2 怎样将一个字符串转码为UTF-8？

=head2 How do I convert a string to UTF-8?

If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade
one of the strings to UTF-8. If you've got an SV, the easiest way to do
this is:

如果你混合了UTF-8和非UTF-8的字符串，你需要将其中的字符串转码为UTF-8。
如果你拿到的是SV，最简单的方式是：

    sv_utf8_upgrade(sv);

However, you must not do this, for example:

然而，你并不是一定要这样做，例如：

    if (!SvUTF8(left))
        sv_utf8_upgrade(left);

If you do this in a binary operator, you will actually change one of the
strings that came into the operator, and, while it shouldn't be noticeable
by the end user, it can cause problems in deficient code.

如果你在一个二元操作符中这样做，你将会改变其中一个传入参数，
然而，这不应该让最终用户察觉到，可能会在一些有缺陷的代码中导致问题。

Instead, C<bytes_to_utf8> will give you a UTF-8-encoded B<copy> of its
string argument. This is useful for having the data available for
comparisons and so on, without harming the original SV. There's also
C<utf8_to_bytes> to go the other way, but naturally, this will fail if
the string contains any characters above 255 that can't be represented
in a single byte.

取代的做法是，C<bytes_to_utf8>将会给你一个UTF-8编码的字符串参数拷贝。
对于数据比较来说非常有用，而且不会修改原有的SV。同样有一个C<utf8_to_bytes>功能恰好相反。
但是如果你的字符串中包含大于255的字符，将会调用失败，因为无法被表示为单个字节。

=head2 我还需要知道其他东西么？

=head2 Is there anything else I need to know?

Not really. Just remember these things:

没有什么了。只要记住这些就可以：

=over 3

=item *

There's no way to tell if a string is UTF-8 or not. You can tell if an SV
is UTF-8 by looking at its C<SvUTF8> flag. Don't forget to set the flag if
something should be UTF-8. Treat the flag as part of the PV, even though
it's not - if you pass on the PV to somewhere, pass on the flag too.

没有办法知道一个字符串是否为UTF-8编码。你可以通过查看一个SV的C<SvUTF8>标记来看它是否为UTF-8编码。
不要忘记为那些应该是UTF-8的东西设置标记。将标记看作PV的一部分，即使它其实不是--如果你将PV传递给什么的话，记得传递这个标志。

=item *

If a string is UTF-8, B<always> use C<utf8_to_uvchr_buf> to get at the value,
unless C<UTF8_IS_INVARIANT(*s)> in which case you can use C<*s>.

如果字符串为UTF-8，总是使用C<utf8_to_uvchr_buf>以获取值，
除非C<UTF8_IS_INVARIANT(*s)>，这种情况下使用C<*s>。

=item *

When writing a character C<uv> to a UTF-8 string, B<always> use
C<uvchr_to_utf8>, unless C<UTF8_IS_INVARIANT(uv))> in which case
you can use C<*s = uv>.

当向一个UTF-8字符串写入V<uv>的时候，通常要使用C<uvchr_to_utf8>，
除非C<UTF8_IS_INVARIANT(uv))>，在这种情况下你可以使用C<*s = uv>。

=item *

Mixing UTF-8 and non-UTF-8 strings is tricky. Use C<bytes_to_utf8> to get
a new string which is UTF-8 encoded, and then combine them.

混合使用UTF-8和非UTF-8字符串是令人困惑的。使用C<bytes_to_utf8>获取一个新的UTF-8编码的字符串，然后合并它们。

=back

=head1 定制操作符

=head1 Custom Operators

Custom operator support is an experimental feature that allows you to
define your own ops. This is primarily to allow the building of
interpreters for other languages in the Perl core, but it also allows
optimizations through the creation of "macro-ops" (ops which perform the
functions of multiple ops which are usually executed together, such as
C<gvsv, gvsv, add>.)

定制操作符是一个实验性的特性可以使得你能够定义你自己的操作符。
这原本是为了允许在Perl和性中构建其他语言的解释器而设立的，
但是它也允许通过创建"macro-ops"（可以同时执行多条ops功能的ops，比如C<gvsv, gvsv, add>。）进行优化。

This feature is implemented as a new op type, C<OP_CUSTOM>. The Perl
core does not "know" anything special about this op type, and so it will
not be involved in any optimizations. This also means that you can
define your custom ops to be any op structure - unary, binary, list and
so on - you like.

这个特性通过一个新的op类型实现，C<OP_CUSTOM>。Perl内核不知道关于这个op类型的任何信息，
因此也不会参与任何优化。这同样意味着你可以定义你自己的通用op为任何op结构 - 一元，二元，列表 等等。

It's important to know what custom operators won't do for you. They
won't let you add new syntax to Perl, directly. They won't even let you
add new keywords, directly. In fact, they won't change the way Perl
compiles a program at all. You have to do those changes yourself, after
Perl has compiled the program. You do this either by manipulating the op
tree using a C<CHECK> block and the C<B::Generate> module, or by adding
a custom peephole optimizer with the C<optimize> module.

知道定制操作符不会为你做什么非常重要。它们不会让你直接为Perl添加新的语法。事实上，
它们不会改变Perl编译一个程序的过程。在Perl编译完程序后你必须要自己做这些。
你可以通过使用C<CHECK>块和C<B::Generate>模块管理op树的方式或使用C<optimize>模块添加一个定制窥孔优化器的方式来做实现这些改变。

When you do this, you replace ordinary Perl ops with custom ops by
creating ops with the type C<OP_CUSTOM> and the C<op_ppaddr> of your own
PP function. This should be defined in XS code, and should look like
the PP ops in C<pp_*.c>. You are responsible for ensuring that your op
takes the appropriate number of values from the stack, and you are
responsible for adding stack marks if necessary.

当你做这件事的时候，你将普通的Perl ops替换为定制的ops

You should also "register" your op with the Perl interpreter so that it
can produce sensible error and warning messages. Since it is possible to
have multiple custom ops within the one "logical" op type C<OP_CUSTOM>,
Perl uses the value of C<< o->op_ppaddr >> to determine which custom op
it is dealing with. You should create an C<XOP> structure for each
ppaddr you use, set the properties of the custom op with
C<XopENTRY_set>, and register the structure against the ppaddr using
C<Perl_custom_op_register>. A trivial example might look like:

    static XOP my_xop;
    static OP *my_pp(pTHX);

    BOOT:
        XopENTRY_set(&my_xop, xop_name, "myxop");
        XopENTRY_set(&my_xop, xop_desc, "Useless custom op");
        Perl_custom_op_register(aTHX_ my_pp, &my_xop);

The available fields in the structure are:

=over 4

=item xop_name

A short name for your op. This will be included in some error messages,
and will also be returned as C<< $op->name >> by the L<B|B> module, so
it will appear in the output of module like L<B::Concise|B::Concise>.

=item xop_desc

A short description of the function of the op.

=item xop_class

Which of the various C<*OP> structures this op uses. This should be one of
the C<OA_*> constants from F<op.h>, namely

=over 4

=item OA_BASEOP

=item OA_UNOP

=item OA_BINOP

=item OA_LOGOP

=item OA_LISTOP

=item OA_PMOP

=item OA_SVOP

=item OA_PADOP

=item OA_PVOP_OR_SVOP

This should be interpreted as 'C<PVOP>' only. The C<_OR_SVOP> is because
the only core C<PVOP>, C<OP_TRANS>, can sometimes be a C<SVOP> instead.

=item OA_LOOP

=item OA_COP

=back

The other C<OA_*> constants should not be used.

=item xop_peep

This member is of type C<Perl_cpeep_t>, which expands to C<void
(*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)>. If it is set, this function
will be called from C<Perl_rpeep> when ops of this type are encountered
by the peephole optimizer. I<o> is the OP that needs optimizing;
I<oldop> is the previous OP optimized, whose C<op_next> points to I<o>.

=back

C<B::Generate> directly supports the creation of custom ops by name.

=head1 AUTHORS

Until May 1997, this document was maintained by Jeff Okamoto
E<lt>okamoto@corp.hp.comE<gt>.  It is now maintained as part of Perl
itself by the Perl 5 Porters E<lt>perl5-porters@perl.orgE<gt>.

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, and Gurusamy Sarathy.

=head1 SEE ALSO

L<perlapi>, L<perlintern>, L<perlxs>, L<perlembed>

